<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="images/favicon.png" rel="icon" type="image/png" />
    <title>Provable Documentation</title>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-127522344-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-127522344-1');
    </script>

    <style>
      #logoc {
        text-align: center;
        left: 0;
        right: 0;
        margin: auto;
      }
      #logoMAIN {
        padding: 10px;
        text-align: center;
        left: 0;
        right: 0;
        margin: auto;
      }
      #logoText {
        text-align: center;
        left: 0;
        right: 0;
        margin: auto;
        color: #FFF;
        font-size: 1.75em;
      }
      #lastupdate {
	position: fixed;
	bottom: 10px;
	font-size: 1.13em;
        background-color: #393939;
	/*font-style: italic;*/
      }
      #chat {
        display: none;
        position: fixed;
        bottom: 10px;
        right: 20px;
        z-index: 10;
      }
      .extratitle {
        font-size: 30px;
      }
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #272822;
  background-color: #f92672;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #75715e;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #f8f8f2;
}
.highlight .p, .highlight .pi {
  color: #f8f8f2;
}
.highlight .gi {
  color: #a6e22e;
}
.highlight .gd {
  color: #f92672;
}
.highlight .gh {
  color: #66d9ef;
  background-color: #272822;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #ae81ff;
}
.highlight .kc {
  color: #fd971f;
}
.highlight .kt {
  color: #fd971f;
}
.highlight .kd {
  color: #fd971f;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #a6e22e;
}
.highlight .sr {
  color: #a1efe4;
}
.highlight .si {
  color: #cc6633;
}
.highlight .se {
  color: #cc6633;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #66d9ef;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #a6e22e;
}
.highlight .ss {
  color: #a6e22e;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;javascript&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <div id="logoc">
      <img src="images/logo.svg" alt="Oraclize log" id="logoMAIN" width="100px">
      </div>
        <div class="lang-selector">
              <a href="#" data-language-name="javascript"></a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='https://github.com/provable-things/docs/wiki' target='_blank'>Suggest an edit</a></li>
            <li><a href='https://gitter.im/provable/home' target='_blank'>Join the Provable Dev Community</a></li>
            <li><span id='lastupdate'></span></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        
          <h1 id='home'>Home</h1>
<p>Welcome to the Documentation of Provable!</p>

<p>The documentation is divided in the following sections:</p>

<ul>
<li><a href="#background">Background</a>: the rationale behind the Provable&#39;s Oracle Model</li>
<li><a href="#general-concepts">General Concepts</a>: the main concepts behind Provable</li>
<li><a href="#data-sources">Data-Sources</a>:  information regarding the types of data sources Provable supports</li>
<li><a href="#integrations">Integrations</a>: how to integrate a blockchain application with Provable</li>
<li><a href="#development-tools">Development Tools</a>: a list of tools to aide development of Provable-integrated smart contracts</li>
<li><a href="#security-deep-dive">Security Deep Dive</a>: how Provable&#39;s Authenticity proofs works</li>
<li><a href="#pricing">Pricing</a>: information on our pricing model for production uses</li>
<li><a href="#tutorials">Tutorials</a>: tutorials on our Provable integrations</li>
</ul>

          <h1 id='background'>Background</h1>
<p>Provable is the leading oracle service for smart contracts and blockchain applications, serving thousands of requests every day on platforms like <a href="#ethereum">Ethereum</a>, <a href="#rootstock">Rootstock</a>, <a href="#corda">R3 Corda</a>, <a href="#fabric">Hyperledger Fabric</a> and <a href="#eos">EOS</a>.</p>

<p>In the blockchain space, an oracle is a party which provides data. The need for such figure arise from the fact that blockchain applications, such as Bitcoin scripts and smart contracts cannot access and fetch directly the data they require: price feeds for assets and financial applications; weather-related information for peer-to-peer insurance; random number generation for gambling.</p>

<p>But to rely on a new trusted intermediary, the oracle in this case, it would be betraying the security and reduced-trust model of blockchain applications: which is what makes them interesting and useful in first place.</p>

<p>One solution is to accept data inputs from more than one untrusted or partially trusted party and then execute the data-dependent action only after a number of them have provided the same answer or an answer within some constrains. This type of system can be considered a decentralized oracle system. Unfortunately, this approach has severe limitations:</p>

<ul>
<li>It requires a predefined standard on data format</li>
<li>It is inherently inefficient: all the parties participating will require a fee and, for every request, it will take time before reaching a sufficient number of answers.</li>
</ul>

<p>The solution developed by Provable is instead to demonstrate that the data fetched from the original data-source is genuine and untampered. This is accomplished by accompanying the returned data together with a document called authenticity proof. The authenticity proofs can build upon different technologies such as auditable virtual machines and Trusted Execution Environments.</p>

<p>A more detailed overview of Provable authenticity proofs is provided in the <a href="#ethereum-quick-start-authenticity-proofs">Authenticity Proofs</a> section of this documentation.</p>

<p>This solution elegantly solves the Oracle Problem:</p>

<ul>
<li>Blockchain Application&#39;s developers and the users of such applications don&#39;t have to trust Provable; the security model is maintained.</li>
<li>Data providers don&#39;t have to modify their services in order to be compatible with blockchain protocols. Smart contracts can directly access data from Web sites or APIs.</li>
</ul>

<p>Provable engine can be easily integrated with both private and public instances of different blockchain protocols.</p>

<p>While building the service, the Provable team has realized that the concept of authenticity proofs has much broader applicability than initially envisioned. For example, the Provable Random Data-source can be used even by traditional gambling applications to ensure users of continuous fairness of operation</p>

          <h1 id='general-concepts'>General Concepts</h1>
<p>Provable is integrated with a number of blockchain protocols and its service is useful and accessible also for non-blockchain applications. In the following section, general concepts which apply to all integrations will be explained.</p>
<h2 id='provable-engine'>Provable Engine</h2>
<p>The Provable Engine powers the service for both blockchain-based and non-blockchain-based application. Internally replicates an &quot;If This Then That&quot; logical model. This means that it will execute a given set of instructions if some other given conditions are met. For example, it could repeatedly verify a condition and only return data or perform an action when the condition has been met. This flexibility enables the engine to be leveraged in many different ways and contexts, even outside of the blockchain context.</p>

<p>A valid request for data to Provable, done via the native blockchain integration or via the HTTP API, should specify the following arguments:</p>

<ul>
<li>A data source type</li>
<li>A query</li>
<li>Optionally, an authenticity proof type</li>
</ul>
<h2 id='data-source-types'>Data Source Types</h2>
<p>A data source is a trusted provider of data. It can be a website or web API such as Reuters, Weather.com, BBC.com, or a secure application running on an hardware-enforced Trusted Execution Environment (TEE) or an auditable, locked-down virtual machine instance running in a cloud provider. Provable currently offers the following types of native data sources:</p>

<ul>
<li><strong>URL</strong>: enables the access to any webpage or HTTP API endpoint</li>
<li><strong>WolframAlpha</strong>: enables native access to WolframAlpha computational engine</li>
<li><strong>IPFS</strong>: provides access to any content stored on an IPFS file</li>
<li><strong>random</strong>: provides untampered random bytes coming from a secure application running on a Ledger Nano S.</li>
<li><strong>computation</strong>: provides the result of arbitrary computation</li>
</ul>

<p>Additionaly, there also some meta data source such as:</p>

<ul>
<li><strong>nested</strong>: enables the combination of different types of data source or multiple requests using the same data source, and it returns an unique result</li>
<li><strong>identity</strong>: it returns the query</li>
<li><strong>decrypt</strong>: it decrypts a string encrypted to the Provable private key</li>
</ul>
<h2 id='query'>Query</h2>
<p>A query is an array of parameters which needs to be evaluated in order to complete a specific data source type request: <code>query: [ parameter_1, parameters_2, ...];</code></p>

<p>The first parameter is the main argument and it is usually mandatory. For example, in the case of the URL Data Source Type, the first argument is the expected URL where the resource resides. If only the first argument is present, then the URL Data Source assumes that an HTTP GET was requested. The second parameters, which it is optional, should contain the data payload of the HTTP POST request.</p>

<p>The intermediate result of a query may need to be parsed: for example, to extract a precise field in JSON API response. Therefore, the query can also specify parsing helpers to be applied.</p>
<h2 id='parsing-helpers'>Parsing Helpers</h2>
<p>Provable offers JSON, XML, XHTML and a binary parser helpers. Examples:</p>

<ul>
<li><strong>JSON Parsing</strong>: To extract the value of a specific element from a JSON document, you may use our built-in JSON parser. An example usage case, for extracting the ETH/USD price field from the Kraken API, serving it as a JSON doc, is by surrounding the API endpoint in question with the helper as follows: <code>json(https://api.kraken.com/0/public/Ticker?pair=ETHUSD).result.XETHZUSD.c.0</code>.</li>
<li><strong>XML Parser</strong>: To extract the value of a specific element from an XML document, you may use our built-in XML parser. An example usage case, for extracting the diesel price from an API serving it as an XML doc, is by surrounding the API endpoint in question with the helper as follows: <code>xml(https://www.fueleconomy.gov/ws/rest/fuelprices).fuelPrices.diesel</code>.</li>
<li><strong>HTML Parser</strong>: Useful for HTML scraping. The desired <a href="https://en.wikipedia.org/wiki/XPath" target="_blank">XPATH</a> can be specified as argument of <code>xpath(..)</code>as shown in the example: <code>html(https://twitter.com/oraclizeit/status/671316655893561344).xpath(//*[contains(@class, &#39;tweet-text&#39;)]/text())</code>.</li>
<li><strong>Binary Helper</strong>: It can be useful to extract parts of a binary intermediate result by using the <code>slice(offset,length)</code> operator.
The first parameter is the expected to be the offset, while the second one is the length of the returned slice.
For example, <code>binary(https://www.sk.ee/crls/esteid/esteid2015.crl).slice(0,300)</code>returns the raw bytes of the first certificate of the linked certificate revocation list.
<strong>Binary helper must be used with the slice option and only raw binary inputs are accepted</strong></li>
</ul>

<aside class="notice">
Note:
Provable `json()` and `xpath()` helpers support respectively JSONPATH and XPATH standards. The JSONPATH implementation is fully compatible with <a href="https://github.com/FlowCommunications/JSONPath#expression-syntax" target="_blank">FlowCommunications JSONPath 0.3.4</a>, which can be easily tested via <a href="https://jsonpath.curiousconcept.com/" target="_blank">this external website</a>. The XPATH implementation that we use is fully compatible with the <a href="https://www.w3.org/TR/xpath/" target="_blank">XPATH 1.0 standard</a>.
</aside>

<p>Please, note that the Provable Test Query Page tool, can be useful to test any Provable Query
leveraging the Parsing Helpers. More details in the &quot;<a href="#development-tools-test-query">Development Tools Test Query</a>&quot; section.</p>
<h2 id='authenticity-proofs'>Authenticity Proofs</h2>
<p>Provable is designed to act as an untrusted intermediary. Optionally, a request to Provable can specify an authenticity proof. Not all proofs are compatible with all data source types. More details on the authenticity proofs can be found in the &quot;<a href="#security-deep-dive">Security Deep Dive</a>&quot; section.</p>

<aside class="notice">
Always use https:// calls when working with authenticity proofs, otherwise your request might get tampered with during the process (MITM attacks) and no detection of such attacks would be possible.
</aside>

<aside class="notice">
If Provable is unable to generate an authenticity proof for technical reasons, it will return in most cases the result without the requested proof. It is up to the developer to decide how to handle this case in their application: Provable recommends to discard the result and create a new query.
</aside>
<h2 id='data-privacy'>Data Privacy</h2>
<p>Certain contexts, such as smart contracts on public blockchains, might require a level of privacy to protect data from public scrutiny. Developers can make encrypted Provable queries by encrypting an entire query or some of its arguments with the Provable public key.
More information can be found in the <a href="#ethereum-advanced-topics-encrypted-queries">Encrypted Queries</a> section.</p>

          <h1 id='data-sources'>Data Sources</h1>
<p>Listed here are the data-sources you can choose from when using our oracle service.<br>Please note that datasource selection is <i>not</i> case-sensitive.</p>

<table>
  <tr>
    <td></td>
    <td>None</td>
    <td>TLSNotary</td>
    <td>Android</td>
    <td>Ledger</td>
  </tr>
  <tr>
    <td><a href="#data-sources-url">URL</a></td>
    <td>✓</td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#data-sources-random">Random</a></td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>✓</td>
  </tr>
  <tr>
    <td><a href="#data-sources-wolframalpha">WolframAlpha</a></td>
    <td>✓</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#data-sources-ipfs">IPFS</a><sup> 1</sup></td>
    <td>✓</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td><a href="#data-sources-computation">computation</a><sup> 1</sup></td>
    <td>✓</td>
    <td>✓</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
</table>
<h2 id='url'>URL</h2>
<p>The <code>URL</code> data source type enables access to any API or web page on the Internet. It supports both HTTP GET and HTTP POST request.
If only one parameters is specified in the query, the service will default to perform an HTTP GET request. If a second parameter is specified, then the service will perform an HTTP POST request, posting the second parameter as data. Note that if the second parameter is valid JSON, then it will be posted as such. The <code>URL</code> data source type supports TLSNotary Proofs and Android Proofs.
More advanced HTTP capabilities, such as Basic Authentication or OAuth, can be build by leveraging the <code>computation</code> data source type.</p>

<aside class="notice">
As Provable is a remote service, it requires the `URL` datasource to also be remotely accessible. In case a developer may wish to use an API that is accessible only on their local network, they may use the `localtunnel` utility available via `npm` to expose their local port via a publicly accessible url (which is what is to be used as the query parameter, in place of localhost:8080 or 127.0.0.1). More information on this utility is available at: <a href="https://localtunnel.github.io/www/" target="_blank">https://localtunnel.github.io/www/</a>
</aside>
<h2 id='wolframalpha'>WolframAlpha</h2>
<p>The <code>WolframAlpha</code> data source type enables direct access to the WolframAlpha Knowledge Engine API. This datasource expects as sole parameter the string which should be passed to WolframAlpha. It will returns the result as a string.</p>

<aside class="notice">
Developers should test the validity of the query via Provable's Test Page to make sure your syntax makes sense to Wolfram's engine.
</aside>

<aside class="notice">
This data source doesn't support authenticity proofs as returning the whole API response is against WolframAlpha Terms of Service. For this reason, Provable recommends to use this data source type only for testing.
</aside>
<h2 id='ipfs'>IPFS</h2>
<p>The <code>IPFS</code> data source type can be used to retrieve the content of a file on the IPFS network.</p>

<p>This datasource expects as sole parameter the IPFS multihash in the query. For example, the file <code>QmT78zSuBmuS4z925WZfrqQ1qHaJ56DQaTfyMUF7F8ff5o</code> would return `&quot;hello world\n&quot;.</p>

<p>If Provable fails to fetch the IPFS content within <i>20</i> seconds, the request will fail.</p>
<h2 id='computation'>computation</h2><pre class="highlight shell tab-shell"><code><span class="c"># Content of the Dockerfile</span>

FROM ubuntu:14.04
MAINTAINER Provable <span class="s2">"info@oraclize.it"</span>
RUN apt-get update <span class="o">&amp;&amp;</span> apt-get install -y python-numpy
CMD python -c <span class="s2">"import numpy; print int(numpy.linalg.det(numpy.array([[1,2,3],[7,2,3],[7,6,3]])))"</span>
</code></pre><pre class="highlight shell tab-shell"><code><span class="c"># How to create the zip archive and upload it on IPFS</span>

<span class="gp">user@locahost:~$ </span>ipfs daemon
<span class="c"># In a new terminal:</span>
<span class="gp">user@locahost:~$ </span>zip -r archive.zip <span class="k">*</span>
<span class="gp">user@locahost:~$ </span>ipfs add archive.zip
added QmRxtL9K2de7v7QBYCCrwcjZHjYmuKggZ8xaqZ6UUWvd1s archive.zip

<span class="c"># Alternative:</span>

<span class="gp">user@locahost:~$ </span>zip -r archive.zip <span class="k">*</span>
<span class="gp">user@locahost:~$ </span>curl -F <span class="s2">"data=@./archive.zip"</span> https://ipfs.infura.io:5001/api/v0/add
<span class="o">{</span><span class="s2">"Name"</span>:<span class="s2">"archive.zip"</span>,<span class="s2">"Hash"</span>:<span class="s2">"QmPz9JxrP8A8pZmtgHZtPwJuTKiaHqU92UzeUDzKDvEz9Q"</span>,<span class="s2">"Size"</span>:<span class="s2">"548"</span><span class="o">}</span>

<span class="c"># Persistance of the file is not garanteed. To make sure it stays online you</span>
<span class="c"># should run your IPFS node / IPFS daemon and keep the archive pinned (pin archive.zip) on your machine.</span>
</code></pre>
<p>The <code>computation</code> datasource enables the auditable execution of an application or a script by leveraging a sandboxed Amazon Web Service virtual machine.</p>

<p>The application has to print, on standard output, the result of the computation as the last line before it quits. The result can be up to 2500 characters long. The execution context has to be described by a <a href="https://docs.docker.com/engine/reference/builder/" target="_blank">Dockerfile</a>, where building and running it should start the main application straight away. Currently Provable only provides one type of auditable instance: a t2.micro instance.  The Dockerfile initialization and application execution should terminate as soon as possible, as the execution time is capped at 5 minutes. (Current Docker version used for computation ds is 1.12.1)</p>

<p>The developer can send to Provable the application binary or the script, its dependency and the Dockerfile by creating an archive and uploading it to IPFS.
The query expects as first argument the IPFS multihash of that archive, while the following arguments will be passed to the execution environment as environmental variables, making them accessible by the application.</p>

<aside class="notice">
Provable might use the email specified in the MAINTAINER field of the Dockerfile, as contact information in case any issue arises.
</aside>

<aside class="notice">
The Dockerfile must be in the root of the archive.zip, not in a subfolder.
</aside>
<h2 id='random'>random</h2>
<p>The design described there prevents Provable from tampering with the random results coming from the Trusted Execution Environment (TEE) and protects the user from a number of attack vectors.</p>

<p>The authenticity proof, attached with the result, can be easily verified not just off-chain but even by any Solidity contract receiving them. <a href="https://github.com/oraclize/ethereum-examples/tree/master/solidity/random-datasource" target="_blank">The example presented here</a>, showing how to integrate the verification process, discards any random result whose authenticity proofs don&#39;t pass the verification process.</p>

<p>The random datasource is leveraging the Ledger proof to prove that the origin of the generated randomness is really a secure Ledger device.</p>

<p>The rationale behind this method of securely feeding off-chain randomness into the blockchain is explained in the <a target="_blank" href="http://www.oraclize.it/papers/random_datasource-rev1.pdf">“A Scalable Architecture for On-Demand, Untrusted Delivery of Entropy”</a> white paper.</p>
<h2 id='decrypt'>decrypt</h2>
<p>Even though the <code>decrypt</code> datasource can be used as any other, it was specifically designed to be used within the <a href="#data-sources-nested"><code>nested</code></a> datasource to enable partial query encryption.</p>

<p>The result is the decrypted query string. <strong>Please note that all the logic, limitations and tools provided by the <code>Encryption</code> feature apply here as well.</strong></p>
<h2 id='nested'>nested</h2>
<p>The <code>nested</code> datasource is a meta datasource, it does not provide access to additional services. It was designed to provide some simple aggregation logic, enabling a single query to leverage sub-queries based on any available datasource and produce a single string as a result.</p>

<p>The <code>query</code> format is built in a way you that you can specify a sub-datasource and a sub-query as follows: <code>[datasource_name] query_content</code>.</p>

<p>Please mind the square brackets delimiting the datasource name and the whitespace prefixing the actual sub-query. The sub-query content can optionally be delimited by either single or double quotes.</p>

<p>You can optionally specify more than one sub-query, by using as delimitators the <code>${</code> special opener and the <code>}</code> special closer.</p>

<p>Example: <code>[WolframAlpha] temperature in ${[IPFS] QmP2ZkdsJG7LTw7jBbizTTgY1ZBeen64PqMgCAWz2koJBL}</code></p>

          <h1 id='integrations'>Integrations</h1><h2 id='public-chains'>Public Chains</h2>
<p>Provable is integrated natively with the most widely used public blockchain protocols like the Ethereum, Bitcoin, Rootstock, EOS mainnets and testnets.</p>
<h2 id='alternative-public-chains'>Alternative Public Chains</h2>
<p>Provable is constantly studying new public blockchain protocols and considering further blockchain integrations. Since the Provable Engine is completely blockchain agnostic and can interact via HTTP API, developers are encouraged to work on open-source independent Provable integration on the model of the Ethereum-Bridge.</p>
<h2 id='private-ethereum-based-chains'>Private Ethereum-based Chains</h2>
<p>Private, Ethereum-based chains can currently integrate with Provable by using the Ethereum-Bridge. Forks of Ethereum such as Monax included. More information on how to use the Ethereum-Bridge will become available in the <a href="#development-tools">development tools</a> section or refer to this <a href="https://ethereum.stackexchange.com/a/11389/5819">StackExchange answer</a> describing how to use it alongside testrpc.</p>
<h2 id='alternative-private-chains'>Alternative Private Chains</h2>
<p>Provable can already be used in most private chains, in case you were interested in using it in a context where it is not integrated yet please <a href="mailto:info@oraclize.it">reach out to us</a>.</p>
<h2 id='non-blockchain-applications'>Non-blockchain Applications</h2>
<p>The <a href="https://github.com/oraclize/oraclize-lib">oraclize-lib</a> enables the use of the Provable engine capabilities also in a non-blockchain context, by providing an abstraction layer which resolves to Provable HTTP API. The oraclize-lib is currently in an experimental stage.</p>

          <h1 id='9830-ethereum'><a style="display:inline-block; min-width:20px">&#9830;</a> Ethereum</h1>
<p>The following section is dedicated to the Ethereum and Provable integration.
To better profit from this section of the documentation, previous knowledge of Solidity and Ethereum is required.</p>

<p>The interaction between Provable and an Ethereum smart contract is asynchronous. Any request for data is composed of two steps:</p>

<ul>
<li>Firstly, in the most common case, a transaction executing a function of a smart contract is broadcasted by a user. The function contains a special instruction which manifest to Provable, who is constantly monitoring the Ethereum blockchain for such instruction, a request for data.</li>
<li>Secondly, according to the parameters of such request, Provable will fetch or compute a result, build, sign and broadcast the transaction carrying the result. In the default configuration, such transaction will execute the <code>__callback</code> function which should be placed in the smart contract by its developer: for this reason, this transaction is referred in the documentation as the Provable callback transaction.</li>
</ul>

<p>As said in previous sections, one of the fundamental characteristics of Provable is the capability of returning data to a smart contract together with one or more proofs of authenticity of the data. The generation of an authenticity proof is optional and it is a contract-wide setting which must be configured by the smart contract developer before the request for data is initiated. Provable always recommends the use of authenticity proofs for production deployments.</p>
<h2 id='quick-start'>Quick Start</h2>
<aside class="notice">
Code examples written here are targetted at Solidity 0.4, and import provableAPI_0.4.25.sol which is a release targetted at Solidity 0.4.25 but compatible down to 0.4.22. It is recommended for any new projects to import whatever the latest API is via `github.com/provable-things/ethereum-api/provableAPI.sol` which ought to target the latest stable Solidity compiler.
</aside>
<pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

   <span class="nx">string</span> <span class="kr">public</span> <span class="nx">ETHUSD</span><span class="p">;</span>
   <span class="nx">event</span> <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">nextStep</span><span class="p">);</span>
   <span class="nx">event</span> <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
   <span class="nx">event</span> <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>

   <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
       <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="s2">"Constructor was initiated. Call 'updatePrice()' to send the Provable Query."</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">provable_cbAddress</span><span class="p">())</span> <span class="nx">revert</span><span class="p">();</span>
       <span class="nx">ETHUSD</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
       <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
   <span class="p">}</span>

   <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
       <span class="k">if</span> <span class="p">(</span><span class="nx">provable_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
           <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
       <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
           <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
           <span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.pro.coinbase.com/products/ETH-USD/ticker).price"</span><span class="p">);</span>
       <span class="p">}</span>
   <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The most simple way to introduce the Ethereum - Provable integration, it is by showing a working example, such as the smart contract on the right.
This contract uses Provable to fetch the last ETH/USD from Coinbase Pro APIs. The update process is initiated every time the function updatePrice() is called. The example shows two important components of using Provable:</p>

<ul>
<li>The contract should be a child of the contract usingProvable</li>
<li>The contract usingProvable is defined in the provableAPI file, which can be fetched from the dedicated Provable Github repository.</li>
</ul>

<p>The code in the example is working out of the box if Remix is used to compile and deploy it on any of the Ethereum networks: main-net and the Ropsten, Kovan and Rinkeby testnets. If, instead, another tool is used, it will be necessary to replace the import statement with a local import of the provableAPI_0.4.25.sol file since direct import from Github may not be supported.</p>

<p>To ease development, Provable doesn&#39;t charge a contract for its first request of data done using the default gas parameters. Successive requests will require the contract to pay the Provable fee and the ether necessary to pay for the callback transaction. Both are automatically taken from the contract balance. If the contract doesn&#39;t have enough funds in his balance, the request will fail and Provable won&#39;t return any data.</p>

<aside class="notice">
Only the first query is free. Ensure that the contract has a sufficient ETH balance to pay the following queries. The contract gets automatically charged on the `provable_query` call but fails if the balance is insufficient.
</aside>
<h3 id='simple-query'>Simple Query</h3><pre class="highlight javascript tab-javascript"><code><span class="c1">// This code example will ask Provable to send as soon as possible</span>
<span class="c1">// a transaction with the primary result (as a string) of the given</span>
<span class="c1">// formula ("random number between 0 and 100") fetched from the</span>
<span class="c1">// data-source "WolframAlpha".</span>
<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"WolframAlpha"</span><span class="p">,</span> <span class="s2">"random number between 0 and 100"</span><span class="p">);</span>

<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"https://api.kraken.com/0/public/Ticker?pair=ETHXBT"</span><span class="p">)</span>

<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span>
  <span class="s2">"json(https://www.therocktrading.com/api/ticker/BTCEUR).result.0.last"</span><span class="p">)</span>

<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"IPFS"</span><span class="p">,</span> <span class="s2">"QmdEJwJG1T9rzHvBD8i69HHuJaRgXRKEQCP7Bh1BVttZbU"</span><span class="p">)</span>

<span class="c1">// The URL datasource also supports a supplement argument, useful for creating HTTP POST requests.</span>
<span class="c1">// If that argument is a valid JSON string, it will be automatically sent as JSON.</span>
<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://shapeshift.io/sendamount).success.deposit"</span><span class="p">,</span>
  <span class="s1">'{"pair":"eth_btc","amount":"1","withdrawal":"1AAcCo21EUc1jbocjssSQDzLna9Vem2UN5"}'</span><span class="p">)</span>
</code></pre>
<p>A request for data is called <strong>query</strong>. The <code>provable_query</code> is a function, inhered from the parent usingProvable contract, which expects at least two arguments:</p>

<ul>
<li>A data-source such as <code>URL</code>, <code>WolframAlpha</code>, <code>IPFS</code>, &#39;Swarm&#39; and others listed here</li>
<li>The argument for the given data-source. For examples:

<ul>
<li>the full <code>URL</code>, which may inclued the use of JSON or XML parsing helpers as it can be seen in the previous example</li>
<li>or a <code>WolframAlpha</code> formula</li>
<li>or an <code>IPFS</code> multihash</li>
</ul></li>
</ul>

<p>The number and type of supported arguments depends from the data-source in use. Beside, few more code example will be shown and commented. The datasource, as well as the authenticity proof chosen, determine the fee which the contract has to pay to Provable.</p>
<h3 id='schedule-a-query-in-the-future'>Schedule a Query in the Future</h3><pre class="highlight javascript tab-javascript"><code><span class="c1">// Relative time: get the result from the given URL 60 seconds from now</span>
<span class="nx">provable_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span>
  <span class="s2">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">)</span>

<span class="c1">// Absolute time: get the result from the given datasource at the specified UTC timestamp in the future</span>
<span class="nx">provable_query</span><span class="p">(</span><span class="nx">scheduled_arrivaltime</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">3600</span><span class="p">,</span>
  <span class="s2">"WolframAlpha"</span><span class="p">,</span> <span class="nx">strConcat</span><span class="p">(</span><span class="s2">"flight "</span><span class="p">,</span> <span class="nx">flight_number</span><span class="p">,</span> <span class="s2">" landed"</span><span class="p">));</span>
</code></pre>
<p>The execution of a query can be scheduled in a future date. The function <code>provable_query</code> accepts as a parameter the delay in seconds from the current time or the timestamp in the future as first argument.
Please note that in order for the future timestamp to be accepted by Provable it must be within <strong>60 days</strong> of the current UTC time in the case of the absolute timestamp choice, or in the case of a relative time elapse, the elapsed seconds must equate to no more than <strong>60 days</strong>.</p>
<h3 id='recursive-queries'>Recursive Queries</h3><pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">ETHUSD</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">nextStep</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="s2">"Constructor was initiated. Call 'updatePrice()' to send the Provable Query."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">provable_cbAddress</span><span class="p">())</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="nx">ETHUSD</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">provable_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
            <span class="nx">provable_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.pro.coinbase.com/products/ETH-USD/ticker).price"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

</code></pre>
<p>Smart contracts using Provable can be effectively autonomous by implementing a new call to Provable into their  <code>__callback</code> method.
This can be useful for implementing periodic updates of some on-chain reference data, as with price feeds, or to periodically check for some off-chain conditions.</p>

<p>This modified version of the previous example will update the ETH/USD exchange rate every 60 seconds, until the contract has enough funds to pay for the Provable fee.</p>

<aside class="notice">
Use recursive queries cautiously. In general it is recommended to send queries purposefully.
</aside>
<h3 id='the-query-id'>The Query ID</h3><pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">ETHUSD</span><span class="p">;</span>
    <span class="nx">mapping</span><span class="p">(</span><span class="nx">bytes32</span><span class="o">=&gt;</span><span class="nx">bool</span><span class="p">)</span> <span class="nx">validIds</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">nextStep</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="s2">"Constructor was initiated. Call 'updatePrice()' to send the Provable Query."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">])</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">provable_cbAddress</span><span class="p">())</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="nx">ETHUSD</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="k">delete</span> <span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">];</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">provable_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
            <span class="nx">bytes32</span> <span class="nx">queryId</span> <span class="o">=</span>
                <span class="nx">provable_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.pro.coinbase.com/products/ETH-USD/ticker).price"</span><span class="p">);</span>
            <span class="nx">validIds</span><span class="p">[</span><span class="nx">queryId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Every time the function <code>provable_query</code> is called, it returns a unique ID, hereby referred to as <code>queryId</code>, which depends from the number of previous requests and the address of smart contract.
The queryId identifies a specific query done to Provable and it is returned to the contract as a parameter of the callback transaction.</p>

<p>Provable recommends smart contract developers to verify if the queryId sent by the callback transaction was generated by a valid call to the <code>provable_query</code> function, as shown in the example accompanying this paragraph. This ensures that each query response is processed only once and helps avoid misuse of the smart contract logic. Moreover, it protects the smart contract during blockchain reorganizations, as explained in the dedicated paragraph of this section.</p>

<p>The <code>queryId</code> can be used as well to implement different behaviors into the <code>__callback</code> function, in particular when there is more than one pending call from Provable.</p>
<h3 id='custom-gas-limit-and-gas-price'>Custom Gas Limit and Gas Price</h3><pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">ETHUSD</span><span class="p">;</span>
    <span class="nx">mapping</span><span class="p">(</span><span class="nx">bytes32</span><span class="o">=&gt;</span><span class="nx">bool</span><span class="p">)</span> <span class="nx">validIds</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">nextStep</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
  <span class="nx">event</span> <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>

    <span class="c1">// This example requires funds to be send along with the contract deployment</span>
    <span class="c1">// transaction</span>
    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">provable_setCustomGasPrice</span><span class="p">(</span><span class="mi">4000000000</span><span class="p">);</span>
        <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="s2">"Constructor was initiated. Call 'updatePrice()' to send the Provable Query."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">])</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">provable_cbAddress</span><span class="p">())</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="nx">ETHUSD</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="k">delete</span> <span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">];</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">provable_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
            <span class="nx">bytes32</span> <span class="nx">queryId</span> <span class="o">=</span>
                <span class="nx">provable_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.pro.coinbase.com/products/ETH-USD/ticker).price"</span><span class="p">,</span> <span class="mi">500000</span><span class="p">);</span>
            <span class="nx">validIds</span><span class="p">[</span><span class="nx">queryId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>The transaction originating from Provable to the  <code>__callback</code> function pays a fee to the miner which include the transaction in a block, just like any other transaction. The miner fee is paid in Ether and it is calculated by taking the amount of gas which covers the execution costs of the transaction multiplied by the selected gas/ether price. Provable will set those parameters accordingly to the parameters specified in the smart contract, for contract-wide settings, and in the <code>provable_query</code> function, for query-specific settings. The miner fee for the callback transaction is taken from the contract balance when the query transaction is executed.</p>

<p>If no settings are specified, Provable will use the default values of 200,000 gas and 20 GWei. This last value is on the higher-end of the pricing spectrum right now, but it helps having faster confirmation times during network-wide congestions.</p>

<p>A different value for the Provable callback gas can be passed as the argument <code>_gasLimit</code> to the <code>provable_query</code> function as shown in the following examples.</p>
<pre class="highlight javascript tab-javascript"><code><span class="c1">// If the callback transaction requires little gas, the value can be lowered:</span>
<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.pro.coinbase.com/products/ETH-USD/ticker).price"</span><span class="p">,</span> <span class="mi">100000</span><span class="p">);</span>

<span class="c1">// Callback methods may be expensive. The example requires the JSON parsing</span>
<span class="c1">// a string in the smart contract. If that's the case, the gas should be increased:</span>
<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"https://api.pro.coinbase.com/products/ETH-USD/ticker"</span><span class="p">,</span> <span class="mi">500000</span><span class="p">);</span>
</code></pre>
<p>The gas price of the callback transaction can be set by calling the <code>provable_setCustomGasPrice</code> function, either in the constructor, which is executed once at deployment of the smart contract, or in a separate function. The following is the ExampleContract modified to specify a custom gas price of 4 Gwei and a custom gas limit for the callback transaction.</p>

<p>Smart contract developers should estimate correctly and minimize the cost of their <code>__callback</code> method, as any unspent gas will be returned to Provable and no refund is available.</p>

<aside class="notice">
When calling `provable_setCustomGasPrice` the parameter type is uint and represents the amount of wei. However, there is no need to put `wei` keyword in the parameter.
</aside>
<h3 id='authenticity-proofs'>Authenticity Proofs</h3><pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">ETHUSD</span><span class="p">;</span>
    <span class="nx">mapping</span><span class="p">(</span><span class="nx">bytes32</span><span class="o">=&gt;</span><span class="nx">bool</span><span class="p">)</span> <span class="nx">validIds</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">nextStep</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>


    <span class="c1">// This example requires funds to be send along with the contract deployment</span>
    <span class="c1">// transaction</span>
    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">provable_setCustomGasPrice</span><span class="p">(</span><span class="mi">4000000000</span><span class="p">);</span>
        <span class="nx">provable_setProof</span><span class="p">(</span><span class="nx">proofType_TLSNotary</span> <span class="o">|</span> <span class="nx">proofStorage_IPFS</span><span class="p">);</span>
        <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="s2">"Constructor was initiated. Call 'updatePrice()' to send the Provable Query."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">bytes</span> <span class="nx">proof</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">])</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">provable_cbAddress</span><span class="p">())</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="nx">ETHUSD</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="k">delete</span> <span class="nx">validIds</span><span class="p">[</span><span class="nx">myid</span><span class="p">];</span>
        <span class="nx">updatePrice</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">provable_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
          <span class="nx">bytes32</span> <span class="nx">queryId</span> <span class="o">=</span>
            <span class="nx">provable_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.pro.coinbase.com/products/ETH-USD/ticker).price"</span><span class="p">,</span> <span class="mi">500000</span><span class="p">);</span>
  <span class="nx">validIds</span><span class="p">[</span><span class="nx">queryId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Authenticity proofs are at the core of Provable&#39;s oracle model. Smart contracts can request authenticity proofs together with their data by calling the <code>provable_setProof</code> function available in the usingProvable contract. The authenticity proof can be either delivered directly to the smart contract or it can be saved, uploaded and stored on some alternate storage medium like <a href="http://ipfs.io/" target="_blank">IPFS</a>.</p>

<p>When a smart contract requests for an authenticity proof, it <strong>must</strong> define a different callback function with the following arguments: <code>function __callback(bytes32 queryId, string result, bytes proof)</code></p>

<p>The <code>provable_setProof</code> function expects the following format: <code>provable_setProof(proofType_ | proofStorage_ )</code></p>

<p>Both proofType and proofStorage are byte constants defined in usingProvable:</p>

<p>Available parameters for proofTypes are:</p>

<ul>
<li><code>proofType_NONE</code>: the default value of any smart contracts</li>
<li><code>proofType_TLSNotary</code>: available only on the <em>Ethereum Mainnet</em></li>
<li><code>proofType_Android</code></li>
<li><code>proofType_Native</code></li>
<li><code>proofType_Ledger</code></li>
</ul>

<p>While for proofStorage:</p>

<ul>
<li><code>proofStorage_IPFS</code></li>
</ul>

<p>For example, <code>provable_setProof(proofType_TLSNotary)</code> will return the full TLSNotary Proof bytes as the proof argument in the callback transaction. If instead <code>provable_setProof(proofType_TLSNotary | proofStorage_IPFS)</code> is used, then Provable will return only the base58-decoded IPFS multihash as the proof argument. To obtain the IPFS multihash, the bytes must be encoded to base58.
The method <code>provable_setProof</code> can be executed in the constructor, becoming a contract-wide lasting setting, or it can be set directly before a specific query is to be made. Authenticity proofs can be disabled by calling <code>provable_setProof(proofType_NONE)</code>. Smart contract developer should be aware that the helper method <code>provable_setProof</code> is an internal function of usingProvable, and therefore it must be included specifically in their smart contract at compile time, before deployment.
The following builds on our previous example:</p>
<h3 id='verifiability'>Verifiability</h3>
<p>Supported proofs can be verified. The following tools can be used: <a href="#development-tools-network-monitor">Verification Tools</a></p>
<h2 id='best-practices'>Best Practices</h2><h3 id='precalculating-the-query-price'>Precalculating the Query Price</h3><pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">KrakenPriceTicker</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">ETHXBT</span><span class="p">;</span>
    <span class="nx">uint</span> <span class="nx">constant</span> <span class="nx">CUSTOM_GASLIMIT</span> <span class="o">=</span> <span class="mi">150000</span><span class="p">;</span>

    <span class="nx">event</span> <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">nextStep</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">newProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">newKrakenPriceTicker</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>


    <span class="kd">function</span> <span class="nx">KrakenPriceTicker</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">provable_setProof</span><span class="p">(</span><span class="nx">proofType_TLSNotary</span> <span class="o">|</span> <span class="nx">proofStorage_IPFS</span><span class="p">);</span>
        <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="s2">"Constructor was initiated. Call 'update()' to send the Provable Query."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">bytes</span> <span class="nx">proof</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">provable_cbAddress</span><span class="p">())</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="nx">ETHXBT</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">newKrakenPriceTicker</span><span class="p">(</span><span class="nx">ETHXBT</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">update</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">provable_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="nx">CUSTOM_GASLIMIT</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">newProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">newProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
            <span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">,</span> <span class="nx">CUSTOM_GASLIMIT</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
<p>You have to consider that your account will be debited for most of your Provable calls. If your contract is not covered with enough ETH, the query will fail. Depending on your contract logic you may want to check the price for your next query before it gets send. You can do this by calling <code>provable_getPrice</code> and check if it is higher than your current contract balance. If that&#39;s the case the <code>provable_query</code> will fail and you may want to handle it gracefully. You can also add a gaslimit parameter to the <code>provable_getPrice</code> function: <code>provable_getPrice(string datasource, uint gaslimit)</code>. Make sure that the custom gaslimit for <code>provable_getPrice</code> matches with the one you will use for <code>provable_query</code>.</p>
<h3 id='mapping-query-ids'>Mapping Query Ids</h3><pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ExampleContract</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="kr">public</span> <span class="nx">ETHUSD</span><span class="p">;</span>
    <span class="nx">event</span> <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">nextStep</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">price</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>

    <span class="nx">mapping</span> <span class="p">(</span><span class="nx">bytes32</span> <span class="o">=&gt;</span> <span class="nx">bool</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">pendingQueries</span><span class="p">;</span>

    <span class="kd">function</span> <span class="nx">ExampleContract</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="s2">"Constructor was initiated. Call 'updatePrice()' to send the Provable Query."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">provable_cbAddress</span><span class="p">())</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="nx">require</span> <span class="p">(</span><span class="nx">pendingQueries</span><span class="p">[</span><span class="nx">myid</span><span class="p">]</span> <span class="o">==</span> <span class="kc">true</span><span class="p">);</span>
        <span class="nx">ETHUSD</span> <span class="o">=</span> <span class="nx">result</span><span class="p">;</span>
        <span class="nx">LogPriceUpdated</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="k">delete</span> <span class="nx">pendingQueries</span><span class="p">[</span><span class="nx">myid</span><span class="p">];</span> <span class="c1">// This effectively marks the query id as processed.</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">updatePrice</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">provable_getPrice</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
          <span class="nx">bytes32</span> <span class="nx">queryId</span> <span class="o">=</span> <span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="s2">"json(https://api.pro.coinbase.com/products/ETH-USD/ticker).price"</span><span class="p">);</span>
          <span class="nx">pendingQueries</span><span class="p">[</span><span class="nx">queryId</span><span class="p">]</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>It might occur that a callback function of a sent query gets called more than once. Therefore it might be helpful to initiate a mapping that manages the query ids and their states. When the callback function of a query gets called, the require statement checks if the current query id needs to be processed. After one successful iteration the id gets deleted to prevent further callbacks for that particular id.</p>
<h2 id='advanced-topics'>Advanced Topics</h2><h3 id='encrypted-queries'>Encrypted Queries</h3>
<p>Certain contexts, such as smart contracts on public blockchains, might require a level of privacy to protect data from public scrutiny. Developers can make encrypted Provable queries by encrypting a part (or all) of a query with the Provable public key.
The encrypted queries feature may be of interested to developers who want to deploy their blockchain applications of public networks. For example, if an application leverages data from an authenticated API, it would be dangerous to disclose the API key to anyway who is monitoring the public chain.</p>

<p>Provable therefore offers the possibility of encrypting the parameters contained in a query to Provable&#39;s public key: <code>044992e9473b7d90ca54d2886c7addd14a61109af202f1c95e218b0c99eb060c7134c4ae46345d0383ac996185762f04997d6fd6c393c86e4325c469741e64eca9</code>
Only Provable will then be able to decrypt the request using its paired private key.</p>

<p>To encrypt the query, Provable provides a CLI tool, which can be found <a href="https://github.com/provable-things/encrypted-queries" target="_blank">here</a>. Alternatively,
The CLI command to encrypt an arbitrary string of text is then:</p>

<p><code>python encrypted_queries_tools.py -e -p 044992e9473b7d90ca54d2886c7addd14a61109af202f1c95e218b0c99eb060c7134c4ae46345d0383ac996185762f04997d6fd6c393c86e4325c469741e64eca9 &quot;YOUR QUERY&quot;</code></p>

<p>This will encrypt the query with the default Provable public key. The encrypted string can then be used as an argument for an Provable query.</p>
<pre class="highlight javascript tab-javascript"><code><span class="c1">// In this example, the entire first argument of an provable_query has been encrypted.</span>
<span class="c1">// The actual string encrypted is:  json(https://poloniex.com/public?command=returnTicker).BTC_ETH.last</span>
<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span><span class="s2">"AzK149Vj4z65WphbBPiuWQ2PStTINeVp5sS9PSwqZi8NsjQy6jJLH765qQu3U/
  bZPNeEB/bYZJYBivwmmREXTGjmKJk/62ikcO6mIMQfB5jBVVUOqzzZ/A8ecWR2nOLv0CKkkkFzBYp2sW1H
  31GI+SQzWV9q64WdqZsAa4gXqHb6jmLkVFjOGI0JvrA/Zh6T5lyeLPSmaslI"</span><span class="p">);</span>
</code></pre>
<aside class="notice">
You could also encrypt only 1 parameter of provable_query(), leaving the other ones in cleartext.
</aside>

<p>The encryption method is also available for POST requests: you can encrypt both the URL and the POST data field as in the following example:</p>
<pre class="highlight javascript tab-javascript"><code><span class="c1">// This is the query that we want to encrypt</span>
<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span><span class="s2">"json(https://api.postcodes.io/postcodes).status"</span><span class="p">,</span>
  <span class="s1">'{"postcodes" : ["OX49 5NU", "M32 0JG", "NE30 1DP"]}'</span><span class="p">)</span>
</code></pre>
<p>Encrypt the datasource (URL in this case):<br>
<code>python encrypted_queries_tools.py -e -p 044992e94... &quot;URL&quot;</code></p>

<p>Returns: <br>
<code>BEIGVzv6fJcFiYQNZF8ArHnvNMAsAWBz8Zwl0YCsy4K/RJTN8ERHfBWtSfYHt+uegdD1wtXTkP30sTW+3xR3w/un1i3caSO0Rfa+wmIMmNHt4aOS</code>
<br>
<br></p>

<p>Encrypt the argument(in this case we are using the JSON parsing helper to retrieve the &quot;status&quot; ):<br>
<code>python encrypted_queries_tools.py -e -p 044992e94... &quot;json(https://api.postcodes.io/postcodes).status&quot;</code></p>

<p>Returns:<br>
<code>BNKdFtmfmazLLR/bfey4mP8v/R5zCIUK7obcUrF2d6CWUMvKKUorQqYZNu1YfRZsGlp/F96CAQhSGomJC7oJa3PktwoW5J1Oti/y2v4+b5+vN8yLIj1trS7p1l341Jf66AjaxnoFPplwLqE=</code>
<br>
<br></p>

<p>Encrypt the JSON (third argument, the data to POST):<br>
<code>python encrypted_queries_tools.py -e -p 044992e94... &#39;{&quot;postcodes&quot; : [&quot;OX49 5NU&quot;, &quot;M32 0JG&quot;, &quot;NE30 1DP&quot;]}&#39;</code></p>

<p>Returns:<br>
<code>BF5u1td9ugoacDabyfVzoTxPBxGNtmXuGV7AFcO1GLmXkXIKlBcAcelvaTKIbmaA6lXwZCJCSeWDHJOirHiEl1LtR8lCt+1ISttWuvpJ6sPx3Y/QxTajYzxZfQb6nCGkv+8cczX0PrqKKwOn/Elf9kpQQCXeMglunT09H2B4HfRs7uuI</code>
<br>
<br></p>
<pre class="highlight javascript tab-javascript"><code><span class="c1">// Finally we add all the encrypted text</span>
<span class="c1">// to the provable_query (in the right order)</span>
<span class="nx">provable_query</span><span class="p">(</span><span class="s2">"BEIGVzv6fJcFiYQNZF8ArHnvNMAsAWBz8Zwl0YCsy4K/RJTN8ERHfBWtSfYHt+
  uegdD1wtXTkP30sTW+3xR3w/un1i3caSO0Rfa+wmIMmNHt4aOS"</span><span class="p">,</span><span class="s2">"BNKdFtmfmazLLR/bfey4mP8
  v/R5zCIUK7obcUrF2d6CWUMvKKUorQqYZNu1YfRZsGlp/F96CAQhSGomJC7oJa3PktwoW5J1Oti/
  y2v4+b5+vN8yLIj1trS7p1l341Jf66AjaxnoFPplwLqE="</span><span class="p">,</span> <span class="s2">"BF5u1td9ugoacDabyfVzoTxPBxG
  NtmXuGV7AFcO1GLmXkXIKlBcAcelvaTKIbmaA6lXwZCJCSeWDHJOirHiEl1LtR8lCt+1ISttWuvp
  J6sPx3Y/QxTajYzxZfQb6nCGkv+8cczX0PrqKKwOn/Elf9kpQQCXeMglunT09H2B4HfRs7uuI"</span><span class="p">);</span>
</code></pre>
<p>You can also do this with a request to another datasource like WolframAlpha, the Bitcoin blockchain, or IPFS. Our encryption system also permits users to encrypt any of the supported datasource options.</p>

<aside class="notice">
In order to prevent other users from using your exact encrypted query ("replay attacks"), the first contract querying Provable with a given encrypted query becomes its rightful "owner". Any other contract using that exact same string will receive an empty result.

As a consequence, remember to always generate a new encrypted string when re-deploying contracts using encrypted queries.
</aside>

<aside class="notice">
The security guarantee mentioned above is only valid on the mainnet, not on the testnet. For more information get in touch with info@provable.xyz
</aside>

<p>To protect the plaintext queries, an Elliptic Curve Integrated Encryption Scheme was chosen. The steps performed for the encryption are the following ones:</p>

<ul>
<li>An Elliptic Curve Diffie-Hellman Key Exchange (ECDH), which uses secp256k1 as the curve and ANSI X9.63 with SHA256 as the Key Derivation Function. This algorithm is used to derive a shared secret from the Provable public key and ad-hoc, randomly generated developer private key.</li>
<li>The shared secret is used by an AES-256 in Galois Counter Mode (GCM), an authenticated symmetric cipher, to encrypt the query string. The authentication tag is 16-bytes of length and the IV is chosen to be &#39;000000000000&#39; (96 bits of length). The IV can be set to the zero byte-array because each shared secret is meant to be a single-use throw-away. Every time the encryption function is called a new developer private key is re-generated. The final ciphertext is the concatenation of the encoded point (i.e the public key of the developer), the authentication tag and the encrypted text.</li>
</ul>
<h3 id='computation-data-source'>Computation Data Source</h3><h4 id='passing-arguments-to-the-package'>Passing Arguments to the Package</h4><pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">Calculation</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

    <span class="nx">string</span> <span class="nx">NUMBER_1</span> <span class="o">=</span> <span class="s2">"33"</span><span class="p">;</span>
    <span class="nx">string</span> <span class="nx">NUMBER_2</span> <span class="o">=</span> <span class="s2">"9"</span><span class="p">;</span>
    <span class="nx">string</span> <span class="nx">MULTIPLIER</span> <span class="o">=</span> <span class="s2">"5"</span><span class="p">;</span>
    <span class="nx">string</span> <span class="nx">DIVISOR</span> <span class="o">=</span> <span class="s2">"2"</span><span class="p">;</span>

    <span class="nx">event</span> <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">calculationResult</span><span class="p">(</span><span class="nx">uint</span> <span class="nx">_result</span><span class="p">);</span>

    <span class="c1">// General Calculation: ((NUMBER_1 + NUMBER_2) * MULTIPLIER) / DIVISOR</span>

    <span class="kd">function</span> <span class="nx">Calculation</span><span class="p">()</span> <span class="p">{</span>
        <span class="nx">provable_setProof</span><span class="p">(</span><span class="nx">proofType_TLSNotary</span> <span class="o">|</span> <span class="nx">proofStorage_IPFS</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">bytes</span> <span class="nx">proof</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">require</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">provable_cbAddress</span><span class="p">());</span>
        <span class="nx">calculationResult</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">result</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">testCalculation</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">sendCalculationQuery</span><span class="p">(</span><span class="nx">NUMBER_1</span><span class="p">,</span> <span class="nx">NUMBER_2</span><span class="p">,</span> <span class="nx">MULTIPLIER</span><span class="p">,</span> <span class="nx">DIVISOR</span><span class="p">);</span> <span class="c1">// = 105</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">sendCalculationQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">_NUMBER1</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">_NUMBER2</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">_MULTIPLIER</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">_DIVISOR</span><span class="p">)</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">provable</span><span class="p">.</span><span class="nx">getPrice</span><span class="p">(</span><span class="s2">"computation"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
          <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
          <span class="nx">provable_query</span><span class="p">(</span><span class="s2">"computation"</span><span class="p">,[</span><span class="s2">"QmZRjkL4U72XFXTY8MVcchpZciHAwnTem51AApSj6Z2byR"</span><span class="p">,</span>
              <span class="nx">_NUMBER1</span><span class="p">,</span>
              <span class="nx">_NUMBER2</span><span class="p">,</span>
              <span class="nx">_MULTIPLIER</span><span class="p">,</span>
              <span class="nx">_DIVISOR</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>Arguments can be passed to the package by adding parameters to the query array. They will be accessible from within the Docker instances as environmental parameters.</p>

<p>Currenty the API supports up to 5 inline arguments, including the IPFS Hash:
<code>provable_query(&quot;computation&quot;,[&quot;QmZRjkL4U72XFXTY8MVcchpZciHAwnTem51AApSj6Z2byR&quot;, _firstOperand, _secondOperand, _thirdOperand, _fourthOperand]);</code></p>
<pre class="highlight shell tab-shell"><code><span class="c"># Content of the Dockerfile</span>

FROM frolvlad/alpine-python3
MAINTAINER Provable <span class="s2">"info@provable.xyz"</span>

COPY calculation.py /

RUN pip3 install requests
CMD python ./calculation.py
</code></pre><pre class="highlight python tab-python"><code><span class="c"># Content of the Python File</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'ARG0'</span><span class="p">])</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'ARG1'</span><span class="p">]))</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'ARG2'</span><span class="p">]))</span> <span class="o">/</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">'ARG3'</span><span class="p">])</span>

<span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
</code></pre><h4 id='passing-more-than-5-arguments'>Passing more than 5 Arguments</h4><pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">Calculation</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

  <span class="nx">event</span> <span class="nx">calculationResult</span><span class="p">(</span><span class="nx">uint</span> <span class="nx">_result</span><span class="p">);</span>
  <span class="nx">event</span> <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>

  <span class="kd">function</span> <span class="nx">Calculation</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
    <span class="nx">provable_setProof</span><span class="p">(</span><span class="nx">proofType_TLSNotary</span> <span class="o">|</span> <span class="nx">proofStorage_IPFS</span><span class="p">);</span>

    <span class="nx">testCalculation</span><span class="p">(</span><span class="s2">"QmeSVrmYimykzzHq9gChwafjQj7DQTyqvkf6Sk92eY3pN3"</span><span class="p">,</span>
    <span class="s2">"33"</span><span class="p">,</span> <span class="s2">"9"</span><span class="p">,</span> <span class="s2">"5"</span><span class="p">,</span> <span class="s2">"2"</span><span class="p">,</span> <span class="s2">"12"</span><span class="p">,</span> <span class="s2">"2"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// (((NUMBER_1 + NUMBER_2) * MULTIPLIER) / DIVISOR) + NUMBER_3 - NUMBER_4 = 115</span>

  <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">bytes</span> <span class="nx">proof</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">require</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">==</span> <span class="nx">provable_cbAddress</span><span class="p">());</span>
    <span class="nx">calculationResult</span><span class="p">(</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">result</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">testCalculation</span><span class="p">(</span>
    <span class="nx">string</span> <span class="nx">_hash</span><span class="p">,</span>
    <span class="nx">string</span> <span class="nx">_number1</span><span class="p">,</span>
    <span class="nx">string</span> <span class="nx">_number2</span><span class="p">,</span>
    <span class="nx">string</span> <span class="nx">_multiplier</span><span class="p">,</span>
    <span class="nx">string</span> <span class="nx">_divisor</span><span class="p">,</span>
    <span class="nx">string</span> <span class="nx">_number3</span><span class="p">,</span>
    <span class="nx">string</span> <span class="nx">_number4</span><span class="p">)</span> <span class="kr">public</span> <span class="nx">payable</span> <span class="p">{</span>

    <span class="nx">string</span><span class="p">[]</span> <span class="nx">memory</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">string</span><span class="p">[](</span><span class="mi">7</span><span class="p">);</span>
    <span class="nx">numbers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_hash</span><span class="p">;</span>
    <span class="nx">numbers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_number1</span><span class="p">;</span>
    <span class="nx">numbers</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_number2</span><span class="p">;</span>
    <span class="nx">numbers</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_multiplier</span><span class="p">;</span>
    <span class="nx">numbers</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_divisor</span><span class="p">;</span>
    <span class="nx">numbers</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_number3</span><span class="p">;</span>
    <span class="nx">numbers</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="nx">_number4</span><span class="p">;</span>

    <span class="nx">sendCalculationQuery</span><span class="p">(</span><span class="nx">numbers</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kd">function</span> <span class="nx">sendCalculationQuery</span><span class="p">(</span><span class="nx">string</span><span class="p">[]</span> <span class="nx">array</span><span class="p">)</span> <span class="nx">internal</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">provable</span><span class="p">.</span><span class="nx">getPrice</span><span class="p">(</span><span class="s2">"computation"</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was NOT sent, please add some ETH to cover for the query fee"</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
      <span class="nx">provable_query</span><span class="p">(</span><span class="s2">"computation"</span><span class="p">,</span> <span class="nx">array</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<p>In case you need to pass more arguments, you will need to send a manually set dynamic string/bytes array, for example:</p>

<p><code>string[] memory myArgs = new string[](6);</code></p>

<p><code>myArgs[0] = &quot;MYIPFSHASH&quot;;</code></p>

<p><code>...</code></p>

<p><code>myArgs[5] = &quot;LAST ARG&quot;;</code></p>

<p>The query would then look like this: <code>provable_query(&quot;computation&quot;, myArgs)</code></p>
<h4 id='passing-encrypted-arguments'>Passing Encrypted Arguments</h4><pre class="highlight javascript tab-javascript"><code><span class="nx">pragma</span> <span class="nx">solidity</span> <span class="o">^</span><span class="mf">0.4</span><span class="p">.</span><span class="mi">22</span><span class="p">;</span>
<span class="kr">import</span> <span class="s2">"github.com/provable-things/ethereum-api/provableAPI_0.4.25.sol"</span><span class="p">;</span>

<span class="nx">contract</span> <span class="nx">ComputationTest</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

    <span class="nx">event</span> <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">nextStep</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="nx">string</span> <span class="nx">description</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogNewResult</span><span class="p">(</span><span class="nx">string</span> <span class="nx">result</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">ComputationTest</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="s2">"Constructor was initiated. Call 'update()' to send the Provable Query."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">myid</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">provable_cbAddress</span><span class="p">())</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="nx">LogNewResult</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">update</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
      <span class="nx">LogNewProvableQuery</span><span class="p">(</span><span class="s2">"Provable query was sent, standing by for the answer.."</span><span class="p">);</span>
      <span class="nx">provable_query</span><span class="p">(</span><span class="s2">"nested"</span><span class="p">,</span> <span class="s2">"[computation] ['QmaqMYPnmSHEgoWRMP3WSrUYsPWKjT85C81PgJa2SXBs8u', \
          'Example of decrypted string', '${[decrypt] BOYnQstP700X10I+WWNUVVNZEmal+rZ0GD1CgcW5P5wUSFKr2QoIwHLvkHfQR5e4Bfakq0CIviJnjkfKFD+ZJzzxcaFUQITDZJxsRLtKuxvAuh6IccUJ+jDF/znTH+8x8EE1Tt9SY7RvqtVao2vxm4CxIWq1vk4=}', 'Hello there!']"</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre>
<p>Encrypted arguments can be passed using the nested and the decrypt meta data sources, as shown in the example at the right.</p>
<h3 id='random-data-source'>Random Data Source</h3>
<p>In the contract usingProvable, which smart contracts should use to interface with Provable, some specific functions related to the Provable Random Data Source have been added. In particular:</p>

<ul>
<li><code>provable_newRandomDSQuery</code>: helper to perform an Provable random DS query correctly

<ul>
<li><code>provable_randomDS_setCommitment</code>: set in the smart contract storage the commitment for the current request</li>
<li><code>provable_randomDS_getSessionPubKeyHash</code>: recovers the hash of a session pub key presents in the connector</li>
</ul></li>
<li><code>provable_randomDS_proofVerify_main</code>: performs the verification of the proof returned with the callback transaction

<ul>
<li><code>provable_randomDS_sessionKeyValidity</code>: verify that the session key chain of trust is valid and its root is a Ledger Root Key</li>
<li><code>matchBytes32Prefix</code>: verify that the result returned is the sha256 of the session key signature over the request data payload</li>
</ul></li>
</ul>

<p>For advance usage of Random Data Source, it is recommended to read the following section.</p>

<aside class="notice">
The random datasource is currently available on the Ethereum mainnet and on all Ethereum public testnets only (Rinkeby, Kovan, Ropsten-revival) - it is not integrated yet with private blockchains/testrpc/remix-ide-vm.
</aside>
<h4 id='two-party-interactions'>Two Party Interactions</h4><pre class="highlight javascript tab-javascript"><code>    <span class="kd">function</span> <span class="nx">provable_newRandomDSQuery</span><span class="p">(</span><span class="nx">uint</span> <span class="nx">_delay</span><span class="p">,</span> <span class="nx">uint</span> <span class="nx">_nbytes</span><span class="p">,</span> <span class="nx">uint</span> <span class="nx">_customGasLimit</span><span class="p">)</span> <span class="nx">internal</span> <span class="nx">returns</span> <span class="p">(</span><span class="nx">bytes32</span><span class="p">){</span>
        <span class="k">if</span> <span class="p">((</span><span class="nx">_nbytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="nx">_nbytes</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">))</span> <span class="nx">revert</span><span class="p">();</span>
        <span class="nx">bytes</span> <span class="nx">memory</span> <span class="nx">nbytes</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">bytes</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="nx">nbytes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kr">byte</span><span class="p">(</span><span class="nx">_nbytes</span><span class="p">);</span>
        <span class="nx">bytes</span> <span class="nx">memory</span> <span class="nx">unonce</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">bytes</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
        <span class="nx">bytes</span> <span class="nx">memory</span> <span class="nx">sessionKeyHash</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">bytes</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
        <span class="nx">bytes32</span> <span class="nx">sessionKeyHash_bytes32</span> <span class="o">=</span> <span class="nx">provable_randomDS_getSessionPubKeyHash</span><span class="p">();</span>
        <span class="nx">assembly</span> <span class="p">{</span>
            <span class="nx">mstore</span><span class="p">(</span><span class="nx">unonce</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
            <span class="nx">mstore</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">unonce</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="nx">xor</span><span class="p">(</span><span class="nx">blockhash</span><span class="p">(</span><span class="nx">sub</span><span class="p">(</span><span class="nx">number</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span> <span class="nx">xor</span><span class="p">(</span><span class="nx">xor</span><span class="p">(</span><span class="nx">caller</span><span class="p">,</span><span class="nx">coinbase</span><span class="p">),</span> <span class="nx">xor</span><span class="p">(</span><span class="nx">callvalue</span><span class="p">,</span><span class="nx">timestamp</span><span class="p">)))</span>
            <span class="nx">mstore</span><span class="p">(</span><span class="nx">sessionKeyHash</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">)</span>
            <span class="nx">mstore</span><span class="p">(</span><span class="nx">add</span><span class="p">(</span><span class="nx">sessionKeyHash</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">),</span> <span class="nx">sessionKeyHash_bytes32</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="nx">bytes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="nx">memory</span> <span class="nx">args</span> <span class="o">=</span> <span class="p">[</span><span class="nx">unonce</span><span class="p">,</span> <span class="nx">nbytes</span><span class="p">,</span> <span class="nx">sessionKeyHash</span><span class="p">];</span>
        <span class="nx">bytes32</span> <span class="nx">queryId</span> <span class="o">=</span> <span class="nx">provable_query</span><span class="p">(</span><span class="nx">_delay</span><span class="p">,</span> <span class="s2">"random"</span><span class="p">,</span> <span class="nx">args</span><span class="p">,</span> <span class="nx">_customGasLimit</span><span class="p">);</span>
        <span class="nx">provable_randomDS_setCommitment</span><span class="p">(</span><span class="nx">queryId</span><span class="p">,</span> <span class="nx">sha3</span><span class="p">(</span><span class="nx">bytes8</span><span class="p">(</span><span class="nx">_delay</span><span class="p">),</span> <span class="nx">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nx">sha256</span><span class="p">(</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nx">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]));</span>
        <span class="k">return</span> <span class="nx">queryId</span><span class="p">;</span>
    <span class="p">}</span>

</code></pre>
<p>The <code>provable_newRandomDSQuery</code> can be used for different kind of interactions, but the security can be incresed further by additing additional commitment data to the request. For example, for two party interactions, the <code>provable_newRandomDSQuery</code> can be modified as showon the side to include the sender address and the value send along as commitment data. This more strongly commitment the request for random bytes to current party, which are assumed to have a stake in the contract, making it impossible for miners to replay transactions on potential forks or reorg of the current chain.</p>
<h4 id='multi-party-interactions'>Multi-Party Interactions</h4>
<p>In the case of multi-party interactions, such as voting schemes or lotteries, the commitment data can should include all participants addresses, to ensure that the transaction cannot be replayed by a miner on a fork or a reorged chain where a participant didn&#39;t put a stake.</p>
<h3 id='proofshield'>ProofShield</h3>
<p>The Provable <em>ProofShield</em> is a concept first introduct at Devcon4, you can watch our presentation about &quot;Scalable Onchain Verification for Authenticated Data Feeds and Offchain Computations&quot; <a href="https://www.youtube.com/watch?v=7uQdEBVu8Sk">here</a>.</p>

<aside class="notice">
The ProofShield is still EXPERIMENTAL, please DO NOT use it in production (yet). A production-ready version will follow in the future.
</aside>

<p>The ProofShield enables smart contracts to verify on-chain the authenticity proofs provided by Provable, this ensures that the authenticity of the data received is verified before going ahead and using the data.</p>

<p>To enable the ProofShield it is enough to set it via the <code>provable_setProof</code> function like you see in the following code:</p>
<pre class="highlight javascript tab-javascript"><code>
    <span class="nx">provable_setProof</span><span class="p">(</span><span class="nx">proofType_Android_v2</span> <span class="o">|</span> <span class="nx">proofShield_Ledger</span><span class="p">);</span>

</code></pre>
<p>Once the ProofShield is enabled, the received proof will not be the raw Authenticity Proof, but the ProofShield proof instead: some functions are provided so that the ProofShield proof can be verified on-chain. In order to verify it, you need to call from within the <code>__callback</code> method the function <code>provable_proofShield_proofVerify__returnCode(queryId, result, proof)</code> and ensure that it returns 0.</p>

<aside class="notice">
The ProofShield is currently available on all Ethereum public testnets only (Rinkeby, Kovan, Ropsten-revival) - it is not integrated yet with private blockchains/testrpc/remix-ide-vm.
</aside>

<p>A code example follows, note that the complete version of it is available <a href="https://github.com/provable-things/ethereum-examples/blob/master/solidity/proofshield/proofShieldExample.sol">here</a>:</p>
<pre class="highlight javascript tab-javascript"><code><span class="nx">contract</span> <span class="nx">proofShieldExample</span> <span class="nx">is</span> <span class="nx">usingProvable</span> <span class="p">{</span>

    <span class="nx">event</span> <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="nx">string</span> <span class="nx">nextStep</span><span class="p">);</span>
    <span class="nx">event</span> <span class="nx">LogNewAuthenticatedResult</span><span class="p">(</span><span class="nx">string</span><span class="p">);</span>

    <span class="kd">function</span> <span class="nx">proofShieldExample</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">provable_setProof</span><span class="p">(</span><span class="nx">proofType_Android_v2</span> <span class="o">|</span> <span class="nx">proofShield_Ledger</span><span class="p">);</span>
        <span class="nx">LogConstructorInitiated</span><span class="p">(</span><span class="s2">"Constructor was initiated. Call 'sendQuery()' to send the Provable Query."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">__callback</span><span class="p">(</span><span class="nx">bytes32</span> <span class="nx">queryId</span><span class="p">,</span> <span class="nx">string</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">bytes</span> <span class="nx">proof</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">sender</span> <span class="o">!=</span> <span class="nx">provable_cbAddress</span><span class="p">())</span> <span class="nx">revert</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="nx">provable_proofShield_proofVerify__returnCode</span><span class="p">(</span><span class="nx">queryId</span><span class="p">,</span> <span class="nx">result</span><span class="p">,</span> <span class="nx">proof</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// the proof verification has failed, do we need to take any action here? (depends on the use case)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// the proof verification has passed</span>
            <span class="c1">// now that we know that the random number was safely generated, let's use it..</span>

            <span class="nx">LogNewAuthenticatedResult</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kd">function</span> <span class="nx">sendQuery</span><span class="p">()</span> <span class="nx">payable</span> <span class="p">{</span>
        <span class="nx">string</span> <span class="nx">memory</span> <span class="nx">query</span> <span class="o">=</span> <span class="s2">"json(https://www.bitstamp.net/api/v2/ticker/ethusd/).last"</span><span class="p">;</span>
        <span class="nx">bytes32</span> <span class="nx">queryId</span> <span class="o">=</span> <span class="nx">provable_query</span><span class="p">(</span><span class="s2">"URL"</span><span class="p">,</span> <span class="nx">query</span><span class="p">);</span>

        <span class="nx">provable_proofShield_commitment</span><span class="p">[</span><span class="nx">queryId</span><span class="p">]</span> <span class="o">=</span> <span class="nx">keccak256</span><span class="p">(</span><span class="nx">sha256</span><span class="p">(</span><span class="nx">query</span><span class="p">),</span> <span class="nx">proofType_Android_v2</span><span class="p">);</span>
    <span class="p">}</span>

<span class="p">}</span>
</code></pre><h3 id='more-examples'>More Examples</h3>
<p>More complete, complex examples are available on the dedicated Github repository: <a href="https://github.com/provable-things/ethereum-examples" target="_blank">https://github.com/provable-things/ethereum-examples</a></p>

          <h1 id='9096-rootstock'><a style="display:inline-block; min-width:20px">&#9096;</a> Rootstock</h1>
<p>Rootstock is the first production sidechain of the Bitcoin network. It aims to extends Bitcoin capabilities without compromising its decentralization and censorship resistance properties. On the Rootstock networks, participants are able to interact with smart contracts using a token called Smart Bitcoin. The peg between Bitcoin and Smart Bitcoins is maintained by a federation of distinguished players and backed by merged mining.</p>

<p>The RSK Mainnet and public Testnet are now live and they both have full integration with Provable services.</p>

<p>Smart contracts on Rootstock are executed by an upgraded, but backward compatible version, of the Ethereum Virtual Machine. Those are written using the programming language Solidity and are fully compatible with Ethereum smart contracts.</p>

<p>The Provable Rootstock integration is in fact completely compatible with the Ethereum one, since Ethereum smart contract can be compiled and executed on Rootstock natively.
For more technical details on how to use the Provable service from within Solidity smart contracts, please refer to the <a href="#ethereum-quick-start">Ethereum</a> section of this documentation.</p>

          <h1 id='tritime-eos'><a style="display:inline-block; min-width:20px">&tritime;</a> EOS</h1>
<p>The following section is dedicated to the Provable integration with EOS. Before reading this section, you must be familiar with the key concepts of the EOS platform such as contracts, transactions, actions and CPU/NET/RAM. So if things get blurred the <a href="https://developers.eos.io/">EOSIO Development Portal</a> is your best friend.</p>

<p>The EOS platform supports both C and C++ as programming languages for contracts, however the current Provable integration currently supports <strong>C++ only</strong>.</p>

<aside class="notice">
Provable is currently integrated with the EOSIO Mainnet, the public "Jungle" Testnet and the public "Kylin" Testnet.
</aside>

<aside class="notice">
Provable provides two separate EOS API: one <b>compatible</b> with the <b>CDT 1.6.1</b> and one with the <b>CDT 1.4.0</b>.
</aside>
<h2 id='rationale'>Rationale</h2>
<p>The interaction between Provable and an EOS contract is asynchronous. Any request for data is composed of two steps:</p>

<ul>
<li>Firstly, in the most common case, a transaction executing a given action of a contract is broadcast by a user. That action contains a special instruction which instructs Provable to execute an off-chain task (like the data fetching from a Web API or <a href="#data-sources">potentially much more</a>).</li>
<li>Secondly, according to the parameters of said request, Provable will fetch or compute a result, build, sign and broadcast the transaction carrying the result. In the default configuration, this transaction will execute a <code>callback</code> action which should be placed in the contract by its developer: for this reason, the transaction is referred to in the documentation as the Provable callback transaction.</li>
</ul>

<p>As said in previous sections, one of the fundamental characteristics of Provable is the capability of returning data to a contract together with one or more proofs of authenticity backing the data. The generation of an authenticity proof is optional and it must be configured by the EOS contract developer when the request for data is initiated. Provable always recommends the use of authenticity proofs for production deployments.</p>
<h2 id='quick-start'>Quick Start</h2><pre class="highlight shell"><code><span class="c"># Let's get the "eos_api.hpp" header file</span>
<span class="gp">$ </span>git clone https://github.com/provable-things/eos-api.git provable
</code></pre><h3 id='including-the-provable-api'>Including the Provable API</h3>
<p>Before starting, it is necessary to include the <code>eos_api.hpp</code> header file. This file contains all the helper functions which we will be using to use Provable. The header file can be downloaded from the <a href="https://github.com/provable-things/eos-api">eos-api github repository</a>.
It is highly recommended to always use the latest version.</p>
<pre class="highlight cpp"><code><span class="cp">#include "provable/eos_api.hpp"
</span>
<span class="k">class</span> <span class="nc">eosusdprice</span> <span class="o">:</span> <span class="k">public</span> <span class="n">eosio</span><span class="o">::</span><span class="n">contract</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">using</span> <span class="n">contract</span><span class="o">::</span><span class="n">contract</span><span class="p">;</span>

      <span class="n">eosusdprice</span><span class="p">(</span><span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">code</span><span class="p">,</span> <span class="n">datastream</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">ds</span><span class="p">)</span> <span class="o">:</span> <span class="n">contract</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span> <span class="p">{}</span>

      <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
      <span class="kt">void</span> <span class="n">execquery</span><span class="p">()</span>
      <span class="p">{</span>
          <span class="n">print</span><span class="p">(</span><span class="s">"Sending query to Provable..."</span><span class="p">);</span>
          <span class="n">oraclize_query</span><span class="p">(</span><span class="s">"URL"</span><span class="p">,</span> <span class="s">"json(https://min-api.cryptocompare.com/data/price?fsym=EOS&amp;tsyms=USD).USD"</span><span class="p">,</span>\
           <span class="p">(</span><span class="n">proofType_Android</span> <span class="o">|</span> <span class="n">proofStorage_IPFS</span><span class="p">));</span>
      <span class="p">}</span>

      <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
      <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">eosio</span><span class="o">::</span><span class="n">checksum256</span> <span class="n">queryId</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">proof</span>
      <span class="p">)</span>
      <span class="p">{</span>
          <span class="n">require_auth</span><span class="p">(</span><span class="n">provable_cbAddress</span><span class="p">());</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result_str</span> <span class="o">=</span> <span class="n">vector_to_string</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
          <span class="n">print</span><span class="p">(</span><span class="s">" Result: "</span><span class="p">,</span> <span class="n">result_str</span><span class="p">);</span>
          <span class="n">print</span><span class="p">(</span><span class="s">" Proof length: "</span><span class="p">,</span> <span class="n">proof</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
      <span class="p">}</span>
<span class="p">};</span>

<span class="n">EOSIO_DISPATCH</span><span class="p">(</span><span class="n">eosusdprice</span><span class="p">,</span> <span class="p">(</span><span class="n">execquery</span><span class="p">)(</span><span class="n">callback</span><span class="p">))</span>
</code></pre>
<p>The simplest way to introduce the EOS &lt;-&gt; Provable integration, is by showing a working example, such as the EOS contract on the right.
This contract uses Provable to fetch the last EOS/USD price from the API of CryptoCompare. The update process is initiated every time the action <code>execquery()</code> is called. The example shows two important components of using Provable:</p>

<ul>
<li>The contract should include the Provable header file</li>
<li>the <code>oraclize_query</code> function and the <code>callback</code> action handle all the communication between our EOS contract and Provable</li>
</ul>

<p>The code in the example is working out of the box on any EOS network where Provable is integrated.</p>
<h3 id='simple-query'>Simple Query</h3><pre class="highlight cpp"><code><span class="c1">// This code example will ask Provable to send as soon as possible
// a transaction with the primary result (as a string) of the given
// formula ("random number between 0 and 100") fetched from the
// datasource "WolframAlpha".
</span><span class="n">oraclize_query</span><span class="p">(</span><span class="s">"WolframAlpha"</span><span class="p">,</span> <span class="s">"random number between 0 and 100"</span><span class="p">);</span>

<span class="n">oraclize_query</span><span class="p">(</span><span class="s">"URL"</span><span class="p">,</span> <span class="s">"https://api.kraken.com/0/public/Ticker?pair=ETHXBT"</span><span class="p">)</span>

<span class="n">oraclize_query</span><span class="p">(</span><span class="s">"URL"</span><span class="p">,</span>
  <span class="s">"json(https://www.therocktrading.com/api/ticker/BTCEUR).result.0.last"</span><span class="p">)</span>

<span class="n">oraclize_query</span><span class="p">(</span><span class="s">"IPFS"</span><span class="p">,</span> <span class="s">"QmdEJwJG1T9rzHvBD8i69HHuJaRgXRKEQCP7Bh1BVttZbU"</span><span class="p">)</span>
</code></pre>
<p>A request for data is referred to as a <strong>query</strong>. The <code>oraclize_query</code> is a function, implemented in the <code>oraclize/eos_api.hpp</code> header file, which expects at least two arguments:</p>

<ul>
<li>A datasource such as <code>URL</code>, <code>WolframAlpha</code>, <code>IPFS</code>, &#39;Swarm&#39; and others listed here</li>
<li>The argument for the given datasource. For example:

<ul>
<li>the full <code>URL</code>, which may include the use of JSON or XML parsing helpers as can be seen in the previous example</li>
<li>or a <code>WolframAlpha</code> formula</li>
<li>or an <code>IPFS</code> multihash</li>
</ul></li>
</ul>

<p>The number and type of supported arguments is dependent on the datasource being used. Additionally code examples will be provided to showcase this. The datasource, as well as the authenticity proof chosen, determine the fee which the contract has to pay to Provable.</p>
<h3 id='schedule-a-query-in-the-future'>Schedule a Query in the Future</h3><pre class="highlight cpp"><code><span class="c1">// Relative time: get the result from the given URL 60 seconds from now
</span><span class="n">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s">"URL"</span><span class="p">,</span>
  <span class="s">"json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"</span><span class="p">)</span>

<span class="c1">// Absolute time: get the result from the given datasource at the specified UTC timestamp in the future
</span><span class="n">oraclize_query</span><span class="p">(</span><span class="n">scheduled_arrivaltime</span><span class="o">+</span><span class="mi">3</span><span class="o">*</span><span class="mi">3600</span><span class="p">,</span>
  <span class="s">"WolframAlpha"</span><span class="p">,</span> <span class="n">strConcat</span><span class="p">(</span><span class="s">"flight "</span><span class="p">,</span> <span class="n">flight_number</span><span class="p">,</span> <span class="s">" landed"</span><span class="p">));</span>
</code></pre>
<p>The execution of a query can be scheduled for a future date. The function <code>oraclize_query</code> accepts, as a parameter the, delay in seconds from the current time (relative time) or the unix timestamp of the future date and time (absolute time).
Please note that in order for the future timestamp to be accepted by Provable it must be within <strong>60 days</strong> of the current UTC time in the case of the absolute timestamp choice, or in the case of relative time, the elapsed seconds must equate to no more than <strong>60 days</strong>.</p>
<pre class="highlight cpp"><code><span class="cp">#include "provable/eos_api.hpp"
</span>
<span class="k">class</span> <span class="nc">dieselprice</span> <span class="o">:</span> <span class="k">public</span> <span class="n">eosio</span><span class="o">::</span><span class="n">contract</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">using</span> <span class="n">contract</span><span class="o">::</span><span class="n">contract</span><span class="p">;</span>

      <span class="n">dieselprice</span><span class="p">(</span><span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">code</span><span class="p">,</span> <span class="n">datastream</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">ds</span><span class="p">)</span> <span class="o">:</span> <span class="n">contract</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span> <span class="p">{}</span>

      <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
      <span class="kt">void</span> <span class="n">execquery</span><span class="p">()</span>
      <span class="p">{</span>
          <span class="n">print</span><span class="p">(</span><span class="s">"Sending query to Provable..."</span><span class="p">);</span>
          <span class="n">oraclize_query</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="s">"URL"</span><span class="p">,</span> <span class="s">"xml(https://www.fueleconomy.gov/ws/rest/fuelprices).fuelPrices.diesel"</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
      <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">eosio</span><span class="o">::</span><span class="n">checksum256</span> <span class="n">queryId</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">proof</span>
      <span class="p">)</span>
      <span class="p">{</span>
          <span class="n">require_auth</span><span class="p">(</span><span class="n">provable_cbAddress</span><span class="p">());</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result_str</span> <span class="o">=</span> <span class="n">vector_to_string</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
          <span class="n">print</span><span class="p">(</span><span class="s">"Diesel Price USD: "</span><span class="p">,</span> <span class="n">result_str</span><span class="p">);</span>
      <span class="p">}</span>
<span class="p">};</span>

<span class="n">EOSIO_DISPATCH</span><span class="p">(</span><span class="n">dieselprice</span><span class="p">,</span> <span class="p">(</span><span class="n">execquery</span><span class="p">)(</span><span class="n">callback</span><span class="p">))</span>
</code></pre><h3 id='recursive-queries'>Recursive Queries</h3><pre class="highlight cpp"><code><span class="cp">#include "provable/eos_api.hpp"
</span>
<span class="k">class</span> <span class="nc">wolframrand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">eosio</span><span class="o">::</span><span class="n">contract</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">contract</span><span class="o">::</span><span class="n">contract</span><span class="p">;</span>

    <span class="n">wolframrand</span><span class="p">(</span><span class="n">name</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">name</span> <span class="n">code</span><span class="p">,</span> <span class="n">datastream</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">ds</span><span class="p">)</span> <span class="o">:</span> <span class="n">contract</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span> <span class="p">{}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">getrandomnum</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">oraclize_query</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="s">"WolframAlpha"</span><span class="p">,</span> <span class="s">"random number between 1 and 6"</span><span class="p">);</span>
        <span class="n">print</span><span class="p">(</span><span class="s">" Provable query was sent, standing by for the answer..."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">eosio</span><span class="o">::</span><span class="n">checksum256</span> <span class="n">queryId</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">proof</span>
    <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">require_auth</span><span class="p">(</span><span class="n">provable_cbAddress</span><span class="p">());</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result_str</span> <span class="o">=</span> <span class="n">vector_to_string</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="n">print</span><span class="p">(</span><span class="s">"Result: "</span><span class="p">,</span> <span class="n">result_str</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result_str</span> <span class="o">!=</span> <span class="s">"6"</span><span class="p">)</span>
          <span class="n">getrandomnum</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">EOSIO_DISPATCH</span><span class="p">(</span><span class="n">wolframrand</span><span class="p">,</span> <span class="p">(</span><span class="n">getrandomnum</span><span class="p">)(</span><span class="n">callback</span><span class="p">))</span>
</code></pre>
<p>EOS contracts using Provable can be effectively autonomous by implementing a recurring query to Provable into their <code>callback</code> action.
This can be useful for implementing periodic updates of some on-chain reference data, as with price feeds, or to periodically check for some off-chain conditions.</p>

<p>This modified version of the previous example will get a random number from the WolframAlpha API instead of the EOS/USD price and it will keep retrying every 10 seconds, until the contract has received back the result &quot;6&quot;.</p>

<aside class="notice">
Use recursive queries cautiously. In general it is recommended to send queries purposefully.
</aside>
<h3 id='checking-the-query-id'>Checking the Query ID</h3><pre class="highlight cpp"><code><span class="cp">#define CONTRACT_NAME "checkqueryid"
</span>
<span class="cp">#include "provable/eos_api.hpp"
</span>
<span class="k">class</span> <span class="nc">checkqueryid</span> <span class="o">:</span> <span class="k">public</span> <span class="n">eosio</span><span class="o">::</span><span class="n">contract</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">contract</span><span class="o">::</span><span class="n">contract</span><span class="p">;</span>

    <span class="n">checkqueryid</span><span class="p">(</span><span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">code</span><span class="p">,</span> <span class="n">datastream</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">ds</span><span class="p">)</span> <span class="o">:</span> <span class="n">contract</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span> <span class="p">{}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">checkquery</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">eosio</span><span class="o">::</span><span class="n">checksum256</span> <span class="n">myQueryId</span> <span class="o">=</span> <span class="n">oraclize_query</span><span class="p">(</span><span class="s">"URL"</span><span class="p">,</span> <span class="s">"json(https://api.kraken.com/0/public/Ticker?pair=EOSUSD).result.EOSUSD.l.0"</span><span class="p">);</span>
        <span class="n">oraclize_queryId_localEmplace</span><span class="p">(</span><span class="n">myQueryId</span><span class="p">);</span>
        <span class="n">print</span><span class="p">(</span><span class="s">" Provable query was sent &amp; queryId saved in the queryId table as a record, standing by for the answer..."</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">eosio</span><span class="o">::</span><span class="n">checksum256</span> <span class="n">queryId</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">proof</span>
    <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">require_auth</span><span class="p">(</span><span class="n">provable_cbAddress</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">oraclize_queryId_match</span><span class="p">(</span><span class="n">queryId</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="c1">// The query Id match has failed, manage this use case...
</span>            <span class="n">print</span><span class="p">(</span><span class="s">" Unexpected query ID!"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result_str</span> <span class="o">=</span> <span class="n">vector_to_string</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
            <span class="n">print</span><span class="p">(</span><span class="s">" Result: "</span><span class="p">,</span> <span class="n">result_str</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">EOSIO_DISPATCH</span><span class="p">(</span><span class="n">checkqueryid</span><span class="p">,</span> <span class="p">(</span><span class="n">checkquery</span><span class="p">)(</span><span class="n">callback</span><span class="p">))</span>
</code></pre>
<p>Every time the function <code>oraclize_query</code> is called, it returns a unique ID, hereby referred to as <code>queryId</code>, which is guaranteed to be unique in the given network execution context.
The <code>queryId</code> identifies a specific query done to Provable and it is returned to the contract as a parameter of the callback action.</p>

<p>Provable recommends EOS contract developers to verify if the queryId sent by the callback action was generated by a valid call to the <code>oraclize_query</code> function, as shown in the example accompanying this paragraph. This ensures that each query response is processed only once and helps avoid misuse of the EOS contract logic.</p>
<h4 id='query-id-verification-process'>Query ID Verification Process</h4>
<p>It is a best practice to verify the query ID with the methods provided inside our <code>eos_api.hpp</code>:</p>

<ol>
<li><p>First of all, the macro <code>CONTRACT_NAME</code> has to be defined, where its value will be the name of the contract to deploy.</p></li>
<li><p>The function <code>oraclize_queryId_localEmplace(myQueryId)</code> has to be called, passing as the argument the query ID returned by <code>oraclize_query()</code>. This function will save the query ID in the <code>queryId</code> table as a record. The table will be defined just by importing the API and defining the above macro.</p></li>
<li><p>The function <code>oraclize_queryId_match(queryId)</code> will perform the match between the <code>queryId</code> received by the callback and the query ID available in the <code>queryId</code> table.</p></li>
</ol>

<p>To clarify, the <code>checkqueryid</code> example reproduces all these steps.</p>

<p>The <code>queryId</code> can be used as well to implement different behaviors into the <code>callback</code> function, in particular when there is more than one pending call from Provable.</p>
<h3 id='resource-allocations'>Resource allocations</h3>
<p>The <code>callback</code> action is called by an Provable-controlled account, which will be in charge of allocating the resources for the action execution.
The following restrictions apply:</p>

<ul>
<li>no RAM will be usable by the calling account, so the EOS contract developer should take care, when operations needing RAM are to be executed in the context of the <code>callback</code> function, to define an appropriate payer (i.e.: the contract itself, <code>_self</code>)</li>
<li>the max CPU usage is <code>100 ms</code></li>
<li>the max NET usage is <code>100 kb</code></li>
</ul>

<p>When additional resources are needed the EOS developer could either <a href="mailto:info@oraclize.it">reach out to Provable</a> in order to discuss different arrangements or they could use EOS features to postpone the execution of a resource demanding task with a different payer.</p>

<aside class="notice">
The above mentioned limits are experimental and could change before the launch on the EOS mainnet. In case of abuses some accounts may be temporarily banned from the Provable service.
</aside>
<h3 id='authenticity-proofs'>Authenticity Proofs</h3><pre class="highlight cpp"><code><span class="cp">#include "oraclize/eos_api.hpp"
</span>
<span class="k">class</span> <span class="nc">eosusdprice</span> <span class="o">:</span> <span class="k">public</span> <span class="n">eosio</span><span class="o">::</span><span class="n">contract</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
      <span class="k">using</span> <span class="n">contract</span><span class="o">::</span><span class="n">contract</span><span class="p">;</span>

      <span class="n">eosusdprice</span><span class="p">(</span><span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">code</span><span class="p">,</span> <span class="n">datastream</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">ds</span><span class="p">)</span> <span class="o">:</span> <span class="n">contract</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span> <span class="p">{}</span>

      <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
      <span class="kt">void</span> <span class="n">execquery</span><span class="p">()</span>
      <span class="p">{</span>
          <span class="n">print</span><span class="p">(</span><span class="s">"Sending query to Provable..."</span><span class="p">);</span>
          <span class="n">oraclize_query</span><span class="p">(</span><span class="s">"URL"</span><span class="p">,</span> <span class="s">"json(https://min-api.cryptocompare.com/data/price?fsym=EOS&amp;tsyms=USD).USD"</span><span class="p">,</span>\
           <span class="p">(</span><span class="n">proofType_Android</span> <span class="o">|</span> <span class="n">proofStorage_IPFS</span><span class="p">));</span>
      <span class="p">}</span>

      <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
      <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span>
          <span class="k">const</span> <span class="n">eosio</span><span class="o">::</span><span class="n">checksum256</span> <span class="n">queryId</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">,</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">proof</span>
      <span class="p">)</span>
      <span class="p">{</span>
          <span class="n">require_auth</span><span class="p">(</span><span class="n">provable_cbAddress</span><span class="p">());</span>
          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result_str</span> <span class="o">=</span> <span class="n">vector_to_string</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
          <span class="n">print</span><span class="p">(</span><span class="s">" Result: "</span><span class="p">,</span> <span class="n">result_str</span><span class="p">);</span>
          <span class="n">print</span><span class="p">(</span><span class="s">" Proof length: "</span><span class="p">,</span> <span class="n">proof</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
      <span class="p">}</span>
<span class="p">};</span>

<span class="n">EOSIO_DISPATCH</span><span class="p">(</span><span class="n">eosusdprice</span><span class="p">,</span> <span class="p">(</span><span class="n">execquery</span><span class="p">)(</span><span class="n">callback</span><span class="p">))</span>
</code></pre>
<p>Authenticity proofs are at the core of Provable&#39;s oracle model. EOS contracts can request authenticity proofs together with their data by specifying the proof they want in the last argument of the <code>oraclize_query</code> function. The authenticity proof can be either delivered directly to the EOS contract or it can be uploaded and stored on <a href="http://ipfs.io/" target="_blank">IPFS</a>.</p>

<p>When an EOS contract requests an authenticity proof, it will receive the proof back when the <code>callback</code> action is called, in the form of the <code>std::vector&lt;uint8_t&gt; proof</code> argument.</p>

<p>The <code>proof</code> argument of <code>oraclize_query</code> is designed to be used as follows: <code>oraclize_query(..., (proofType_ | proofStorage_))</code></p>

<p>Both proofType and proofStorage are byte constants defined in the <code>oraclize/eos_api.hpp</code> header file.</p>

<p>Available parameters for proofTypes are:</p>

<ul>
<li><code>proofType_NONE</code>: the default value of any smart contract</li>
<li><code>proofType_TLSNotary</code>: available only on the <em>EOS Mainnet</em></li>
<li><code>proofType_Android</code></li>
<li><code>proofType_Native</code></li>
<li><code>proofType_Ledger</code>: available only with the <em>random datasource</em></li>
</ul>

<p>While for proofStorage:</p>

<ul>
<li><code>proofStorage_IPFS</code></li>
</ul>

<p>For example, <code>oraclize_query(..., (proofType_TLSNotary)</code> will return the full TLSNotary Proof bytes as the proof argument in the callback action. If instead <code>oraclize_query(..., (proofType_TLSNotary | proofStorage_IPFS)</code> is used, then Provable will return only the base58-encoded IPFS multihash as the proof argument.
It is highly recommended to use authenticity proofs at all times, but they can potentially be disabled by setting the <code>proof</code> argument to <code>proofType_NONE</code> or by simply omitting it.</p>
<h3 id='verifiability'>Verifiability</h3>
<p>Supported proofs can be verified. The following tools can be used: <a href="#development-tools-network-monitor">Verification Tools</a></p>
<h2 id='advanced-topics'>Advanced Topics</h2><h3 id='inspecting-contract-queries-cbs'>Inspecting contract queries/cbs</h3><pre class="highlight shell"><code><span class="gp">$ </span>cleos get actions oraclizeex1a -1 -4
<span class="c">#  seq  when                              contract::action =&gt; receiver      trx id...   args</span>
<span class="o">================================================================================================================</span>
?  683   2018-08-10T11:35:57.500       oraclizeconn::query <span class="o">=</span>&gt; oraclizeconn  37b8aefe... <span class="o">{</span><span class="s2">"sender"</span>:<span class="s2">"oraclizeex1a"</span>,<span class="s2">"sversion"</span>:1,<span class="s2">"timestamp"</span>:0,<span class="s2">"queryId...
?  684   2018-08-10T11:36:07.500    oraclizeex1a::callback =&gt; oraclizeex1a  eedc89c4... {"</span>queryId<span class="s2">":"</span>04c11c096b0ff2943e3b7a21e0937b58869286dde7d263f3...
?  685   2018-08-10T11:36:07.500       oraclizeconn::query <span class="o">=</span>&gt; oraclizeconn  eedc89c4... <span class="o">{</span><span class="s2">"sender"</span>:<span class="s2">"oraclizeex1a"</span>,<span class="s2">"sversion"</span>:1,<span class="s2">"timestamp"</span>:0,<span class="s2">"queryId...
?  686   2018-08-10T11:36:14.500    oraclizeex1a::callback =&gt; oraclizeex1a  85cea38a... {"</span>queryId<span class="s2">":"</span>ee512394267cbb9d68b4db24e90901feb0217b592fb20b7a...
</code></pre><pre class="highlight shell"><code><span class="gp">$ </span>cleos get actions oraclizeex1a -1 -4 --console
<span class="c">#  seq  when                              contract::action =&gt; receiver      trx id...   args</span>
<span class="o">================================================================================================================</span>
?  695   2018-08-10T11:48:00.000       oraclizeconn::query <span class="o">=</span>&gt; oraclizeconn  ed95b01a... <span class="o">{</span><span class="s2">"sender"</span>:<span class="s2">"oraclizeex1a"</span>,<span class="s2">"sversion"</span>:1,<span class="s2">"timestamp"</span>:10,<span class="s2">"queryI...
&gt;&gt; {"</span>v<span class="s2">":[1,1],"</span>t<span class="s2">":10,"</span>o<span class="s2">":"</span>oraclizeex1a<span class="s2">","</span>d<span class="s2">":"</span>WolframAlpha<span class="s2">","</span>q<span class="s2">":"</span>random number between 1 and 6<span class="s2">","</span>p<span class="s2">":0,"</span>i<span class="s2">":"</span>81c347bf65790948c3edcac63e07139f62928d9674e661a8633e8f4464ebfd72<span class="s2">"}
?  696   2018-08-10T11:48:00.500    oraclizeex1a::callback =&gt; oraclizeex1a  00b77475... {"</span>queryId<span class="s2">":"</span>2ae5f6edb1b3656c25beb61d0a7ca148c339898e67ac3a6d...
<span class="gp">&gt;&gt; </span>Result:2Provable query was sent, standing by <span class="k">for </span>the answer..
?  697   2018-08-10T11:48:00.500       oraclizeconn::query <span class="o">=</span>&gt; oraclizeconn  00b77475... <span class="o">{</span><span class="s2">"sender"</span>:<span class="s2">"oraclizeex1a"</span>,<span class="s2">"sversion"</span>:1,<span class="s2">"timestamp"</span>:10,<span class="s2">"queryI...
&gt;&gt; {"</span>v<span class="s2">":[1,1],"</span>t<span class="s2">":10,"</span>o<span class="s2">":"</span>oraclizeex1a<span class="s2">","</span>d<span class="s2">":"</span>WolframAlpha<span class="s2">","</span>q<span class="s2">":"</span>random number between 1 and 6<span class="s2">","</span>p<span class="s2">":0,"</span>i<span class="s2">":"</span>ac77896e9560f36d96823ff14efce24e0a443110a8d518f1424f955e6e35a6ee<span class="s2">"}
?  698   2018-08-10T11:48:06.500    oraclizeex1a::callback =&gt; oraclizeex1a  bfdbf675... {"</span>queryId<span class="s2">":"</span>ac77896e9560f36d96823ff14efce24e0a443110a8d518f1...
<span class="gp">&gt;&gt; </span>Result:6
</code></pre>
<p>It is possible to monitor the interaction between a given EOS contract and Provable by using <code>cleos get actions</code>. This will show a high-level view of the actions between the calling contract and the Provable <code>connector</code> contract.
In case you wanted to see more details, it is enough to use the <code>--console</code> option (or <code>-j</code>): this will include any <code>console</code> output you may have generated from your <code>query</code> and <code>callback</code> action.</p>

<p>The <a href="http://app.oraclize.it/home/test_query">test_query page</a> is another useful tool to monitor the processing of Provable queries (using the <code>queryId</code> returned by <code>oraclize_query</code> as an input).</p>
<h3 id='delegating-the-resource-allocation'>Delegating the resource allocation</h3>
<p>When using the <code>oraclize_query</code> function, an EOS action to the Provable <code>connector</code> contract is started. By default the permission for this action is given by the EOS contract account itself. This could be changed, for example, to have the user of the contract paying for the action resources and for the Provable service fees (if any): it is enough to define a macro <code>ORACLIZE_PAYER</code> <strong>before</strong> including the <code>oraclize/eos_api.hpp</code> header file.</p>
<pre class="highlight cpp"><code><span class="cp">#define ORACLIZE_PAYER N(mypayinguser)
</span>
<span class="cp">#include "oraclize/eos_api.hpp"
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">eosio</span><span class="p">;</span>
<span class="p">...</span>
</code></pre><h3 id='computation-data-source'>Computation Data Source</h3><h4 id='passing-arguments-to-the-package'>Passing Arguments to the Package</h4><pre class="highlight cpp"><code><span class="cp">#include "oraclize/eos_api.hpp"
</span>
<span class="k">class</span> <span class="nc">urlrequests</span> <span class="o">:</span> <span class="k">public</span> <span class="n">eosio</span><span class="o">::</span><span class="n">contract</span>
<span class="p">{</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">request</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_query</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_method</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_url</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_kwargs</span>
    <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">string_to_vector</span><span class="p">(</span><span class="n">_query</span><span class="p">),</span>
            <span class="n">string_to_vector</span><span class="p">(</span><span class="n">_method</span><span class="p">),</span>
            <span class="n">string_to_vector</span><span class="p">(</span><span class="n">_url</span><span class="p">),</span>
            <span class="n">string_to_vector</span><span class="p">(</span><span class="n">_kwargs</span><span class="p">)</span>
        <span class="p">};</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">myquery</span> <span class="o">=</span> <span class="n">provable_set_computation_args</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
        <span class="n">oraclize_query</span><span class="p">(</span><span class="s">"computation"</span><span class="p">,</span> <span class="n">myquery</span><span class="p">);</span>
    <span class="p">}</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">contract</span><span class="o">::</span><span class="n">contract</span><span class="p">;</span>

    <span class="n">urlrequests</span><span class="p">(</span><span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">code</span><span class="p">,</span> <span class="n">datastream</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">ds</span><span class="p">)</span> <span class="o">:</span> <span class="n">contract</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span> <span class="p">{}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">reqheadscust</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">print</span><span class="p">(</span><span class="s">"Sending query to Provable..."</span><span class="p">);</span>
        <span class="n">request</span><span class="p">(</span><span class="s">"json(QmdKK319Veha83h6AYgQqhx9YRsJ9MJE7y33oCXyZ4MqHE).headers"</span><span class="p">,</span>
                <span class="s">"GET"</span><span class="p">,</span>
                <span class="s">"http://httpbin.org/headers"</span><span class="p">,</span>
                <span class="s">"{'headers': {'content-type': 'json'}}"</span>
               <span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">reqbasauth</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">request</span><span class="p">(</span><span class="s">"QmdKK319Veha83h6AYgQqhx9YRsJ9MJE7y33oCXyZ4MqHE"</span><span class="p">,</span>
                <span class="s">"GET"</span><span class="p">,</span>
                <span class="s">"http://httpbin.org/basic-auth/myuser/secretpass"</span><span class="p">,</span>
                <span class="s">"{'auth': ('myuser','secretpass'), 'headers': {'content-type': 'json'}}"</span>
               <span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">reqpost</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">request</span><span class="p">(</span><span class="s">"QmdKK319Veha83h6AYgQqhx9YRsJ9MJE7y33oCXyZ4MqHE"</span><span class="p">,</span>
                <span class="s">"POST"</span><span class="p">,</span>
                <span class="s">"https://api.postcodes.io/postcodes"</span><span class="p">,</span>
                <span class="s">"{</span><span class="se">\"</span><span class="s">json</span><span class="se">\"</span><span class="s">: {</span><span class="se">\"</span><span class="s">postcodes</span><span class="se">\"</span><span class="s"> : [</span><span class="se">\"</span><span class="s">OX49 5NU</span><span class="se">\"</span><span class="s">]}}"</span>
               <span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">reqput</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">request</span><span class="p">(</span><span class="s">"QmdKK319Veha83h6AYgQqhx9YRsJ9MJE7y33oCXyZ4MqHE"</span><span class="p">,</span>
                <span class="s">"PUT"</span><span class="p">,</span>
                <span class="s">"http://httpbin.org/anything"</span><span class="p">,</span>
                <span class="s">"{'json' : {'testing':'it works'}}"</span>
               <span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">reqcookies</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">request</span><span class="p">(</span><span class="s">"QmdKK319Veha83h6AYgQqhx9YRsJ9MJE7y33oCXyZ4MqHE"</span><span class="p">,</span>
                <span class="s">"GET"</span><span class="p">,</span>
                <span class="s">"http://httpbin.org/cookies"</span><span class="p">,</span>
                <span class="s">"{'cookies' : {'thiscookie':'should be saved and visible :)'}}"</span>
               <span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">eosio</span><span class="o">::</span><span class="n">checksum256</span> <span class="n">queryId</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">proof</span>
    <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">require_auth</span><span class="p">(</span><span class="n">provable_cbAddress</span><span class="p">());</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">result_str</span> <span class="o">=</span> <span class="n">vector_to_string</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
        <span class="n">print</span><span class="p">(</span><span class="s">"Response: "</span><span class="p">,</span> <span class="n">result_str</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">EOSIO_DISPATCH</span><span class="p">(</span><span class="n">urlrequests</span><span class="p">,</span> <span class="p">(</span><span class="n">reqheadscust</span><span class="p">)(</span><span class="n">reqbasauth</span><span class="p">)(</span><span class="n">reqpost</span><span class="p">)(</span><span class="n">reqput</span><span class="p">)(</span><span class="n">reqcookies</span><span class="p">)(</span><span class="n">callback</span><span class="p">))</span>
</code></pre>
<p>Arguments can be passed to the package by adding parameters to the query array. They will be accessible from within the Docker instance as environmental parameters.</p>

<p>Currently the API supports up to 5 inline arguments, including the IPFS Hash:</p>

<p><code>
std::vector&lt;std::vector&lt;unsigned char&gt;&gt; myquery = {
      string_to_vector(&quot;QmZRjkL4U72XFXTY8MVcchpZciHAwnTem51AApSj6Z2byR&quot;),
      string_to_vector(&quot;_firstOperand&quot;),
      string_to_vector(&quot;_secondOperand&quot;),
      string_to_vector(&quot;_thirdOperand&quot;),
      string_to_vector(&quot;_fourthOperand&quot;)
    };
</code></p>

<p><code>oraclize_query(&quot;computation&quot;, myquery);</code></p>
<h4 id='passing-more-than-5-arguments'>Passing more than 5 Arguments</h4>
<p>In case you need to pass more arguments, you will need to send a manually set dynamic string/bytes array, for example:</p>

<p><code>std::string myArgs[6] = { &quot;MYIPFSHASH&quot;, ... };</code></p>

<p>The query would then look like this: <code>oraclize_query(&quot;computation&quot;, myArgs);</code></p>
<h3 id='random-data-source'>Random Data Source</h3>
<p>Included with the Provable <code>eos_api.hpp</code>, which EOS contracts should use to interface with Provable,
some specific functions related to the Provable Random Data Source have been added. In particular:</p>

<ul>
<li><code>oraclize_newRandomDSQuery</code>: helper to perform an Provable random DS query correctly</li>
<li><code>oraclize_randomDS_proofVerify</code>: performs the verification of the proof returned with the callback transaction</li>
</ul>
<h4 id='specify-the-network-context'>Specify The Network Context</h4>
<p>It is <strong>highly recommended</strong> for the developer to define the <em>network context</em> and the <em>contract name</em> in which the smart contract will operate.</p>

<p>For the network context:</p>

<ul>
<li>For the EOS testnet Jungle: <code>#define ORACLIZE_NETWORK_NAME &quot;eosio_testnet_jungle&quot;</code></li>
<li>For the EOS mainnet <code>#define ORACLIZE_NETWORK_NAME &quot;eosio_mainnet&quot;</code></li>
</ul>

<p>For the contract name:</p>

<ul>
<li><code>#define CONTRACT_NAME &quot;contractname&quot;</code></li>
</ul>
<pre class="highlight cpp"><code><span class="cp">#define ORACLIZE_NETWORK_NAME "eosio_testnet_jungle"
#define CONTRACT_NAME "randomsample"
</span>
<span class="cp">#include "oraclize/eos_api.hpp"
</span>
<span class="k">class</span> <span class="nc">randomsample</span> <span class="o">:</span> <span class="k">public</span> <span class="n">eosio</span><span class="o">::</span><span class="n">contract</span>
<span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">using</span> <span class="n">contract</span><span class="o">::</span><span class="n">contract</span><span class="p">;</span>

    <span class="n">randomsample</span><span class="p">(</span><span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">receiver</span><span class="p">,</span> <span class="n">eosio</span><span class="o">::</span><span class="n">name</span> <span class="n">code</span><span class="p">,</span> <span class="n">datastream</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*&gt;</span> <span class="n">ds</span><span class="p">)</span> <span class="o">:</span> <span class="n">contract</span><span class="p">(</span><span class="n">receiver</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">ds</span><span class="p">)</span> <span class="p">{}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">getrandnum</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">print</span><span class="p">(</span><span class="s">"Sending query to Provable..."</span><span class="p">);</span>
        <span class="kt">uint8_t</span> <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// Possible outputs: [0-255]
</span>        <span class="kt">uint32_t</span> <span class="n">delay</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">oraclize_newRandomDSQuery</span><span class="p">(</span><span class="n">delay</span><span class="p">,</span> <span class="n">N</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">[[</span><span class="n">eosio</span><span class="o">::</span><span class="n">action</span><span class="p">]]</span>
    <span class="kt">void</span> <span class="n">callback</span><span class="p">(</span>
        <span class="k">const</span> <span class="n">eosio</span><span class="o">::</span><span class="n">checksum256</span> <span class="n">queryId</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">proof</span>
    <span class="p">)</span>
    <span class="p">{</span>
        <span class="n">require_auth</span><span class="p">(</span><span class="n">provable_cbAddress</span><span class="p">());</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">oraclize_randomDS_proofVerify</span><span class="p">(</span><span class="n">queryId</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">proof</span><span class="p">,</span> <span class="n">_self</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// The proof verification has failed, manage this use case...
</span>            <span class="n">print</span><span class="p">(</span><span class="s">" Proof failed has failed..."</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">print</span><span class="p">(</span><span class="s">"Number: "</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="n">EOSIO_DISPATCH</span><span class="p">(</span><span class="n">randomsample</span><span class="p">,</span> <span class="p">(</span><span class="n">getrandnum</span><span class="p">)(</span><span class="n">callback</span><span class="p">))</span>
</code></pre><h2 id='more-examples'>More Examples</h2>
<p>More documented, complete and complex examples are available on the dedicated Github repository: <a href="https://github.com/oraclize/eos-examples" target="_blank">https://github.com/oraclize/eos-examples</a></p>
<h2 id='pricing'>Pricing</h2>
<p>The Provable integration with EOS is currently available on the EOSIO Mainnet and on the <strong><a href="http://jungle.cryptolions.io/">EOSIO Public &quot;Jungle&quot; Testnet</a></strong>;</p>

<p>Provable is currently charging <strong>no fee</strong>.</p>

<p>Our standard <a href="#pricing">pricing table</a> may eventually apply (equivalent USD value in <code>EOS</code> tokens
charged), later on the EOSIO Mainnet. If this occurs, the same pricing logic would take place on the
testnet to simulate the functionality. This will be charged in testnet EOS, and so is free.
Contracts that have been deployed during the no-fee period will be considered legacy, and we will
continue to provide our service as it was to them, however, their featureset will stay within the
legacy spectrum as well (i.e. new features dependent on the pricing model are obviously not going to
be transferrable to these).</p>

          <h1 id='c-8226-corda'><a style="display:inline-block; min-width:20px">C&#8226;</a> Corda</h1>
<p>Here we will cover the Provable Corda integration. Before reading this section, you must be familiar with the Corda platform key concepts like flows, subflows, contracts, transactions, commands, oracles etc. So if things get blurred the <a href="https://docs.corda.net/">corda documentation</a> is your best friend.</p>
<h2 id='quick-start'>Quick Start</h2>
<p>The Provable service quite resembles the Oracle model described in Corda, but instead of providing direct access to the <code>query()</code> and <code>sign()</code> methods, it implements a set of flows which can be called when requiring data from the outside world. Look at the following steps to see how this can be achieved.</p>
<h3 id='query-provable'>Query Provable</h3><pre class="highlight java tab-java"><code><span class="n">val</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">subFlow</span><span class="o">(</span><span class="n">OraclizeQueryAwaitFlow</span><span class="o">(</span>
                <span class="n">datasource</span> <span class="o">=</span> <span class="s">"URL"</span><span class="o">,</span>
                <span class="n">query</span> <span class="o">=</span> <span class="s">"json(https://min-api.cryptocompare.com/data/price?fsym=USD&amp;tsyms=GBP).GBP"</span><span class="o">,</span>
                <span class="n">proofType</span> <span class="o">=</span> <span class="n">ProofType</span><span class="o">.</span><span class="na">TLSNOTARY</span>
            <span class="o">))</span>

</code></pre><pre class="highlight java tab-java"><code><span class="n">val</span> <span class="n">proofVerificationTool</span> <span class="o">=</span> <span class="n">OraclizeUtils</span><span class="o">.</span><span class="na">ProofVerificationTool</span><span class="o">()</span>
<span class="k">assert</span><span class="o">(</span> <span class="n">proofVerificationTool</span><span class="o">.</span><span class="na">verifyProof</span><span class="o">(</span><span class="n">answer</span><span class="o">.</span><span class="na">proof</span> <span class="n">as</span> <span class="n">ByteArray</span><span class="o">)</span> <span class="o">)</span>
</code></pre>
<p>The fastest way to query Provable is by using the <code>OraclizeQueryAwaitFlow</code> which accepts the arguments defined in the previous sections (see the <a href="#general-concepts-provable-engine">Provable Engine</a> for additional details).
As shown on the code on the right, the flow fetches the last USD/GBP rate from the APIs specified, requiring a proof of type <em>TLSNotary</em>. Notice that the <code>json(...)</code> parser will exctract exactly the result we are concern about.</p>

<aside class="notice">
    As the communication between flows is blocking, the current flow will remains idle until Provable will dispose back the answer.
</aside>

<p>Once the answer is successfully returned, the proof can be easily verified by using the <code>ProofVerificationTool</code> defined in <code>OraclizeUtils</code>.</p>

<aside class="notice">
To safely check the authenticity of the data received it is customary to verify the proof included in a Provable answer. Once the verifyProof
method succeeds (returning 'true'), the user can be sure that neither Provable nor other Parties have tampered with the results. This can be checked from each party involved in the transaction which has loaded our CorDapp.

Note that the ProofVerificationTool is a module included in Provable's CorDapp and performs the verification locally within the node.
</aside>
<pre class="highlight java tab-java"><code><span class="n">val</span> <span class="n">oracle</span> <span class="o">=</span> <span class="n">serviceHub</span><span class="o">.</span><span class="na">identityService</span>
                <span class="o">.</span><span class="na">wellKnownPartyFromX500Name</span><span class="o">(</span><span class="n">OraclizeUtils</span><span class="o">.</span><span class="na">getNodeName</span><span class="o">())</span> <span class="n">as</span> <span class="n">Party</span>
<span class="n">val</span> <span class="n">answerCommand</span> <span class="o">=</span> <span class="n">Command</span><span class="o">(</span><span class="n">answer</span><span class="o">,</span> <span class="n">oracle</span><span class="o">.</span><span class="na">owningKey</span><span class="o">)</span>
</code></pre>
<p>If you want to put the results in a transaction, it is necessary to wrap the answer in a <code>Command</code> along with Provable&#39;s node public key. Note that Provable&#39;s node can be obtained by using the <code>serviceHub.identityService</code>, identifying the node with <code>OraclizeUtils.getNodeName()</code>.</p>
<h3 id='building-the-transaction'>Building the transaction</h3>
<p>Now we have all the ingredients to build a transaction: check the code on the right to see how it is done.</p>
<pre class="highlight java tab-java"><code><span class="n">val</span> <span class="n">tx</span> <span class="o">=</span> <span class="n">TransactionBuilder</span><span class="o">(</span><span class="n">someNotary</span><span class="o">).</span><span class="na">withItems</span><span class="o">(</span>
                    <span class="n">StateAndContract</span><span class="o">(</span><span class="n">someState</span><span class="o">,</span> <span class="n">SomeContract</span><span class="o">.</span><span class="na">TEST_CONTRACT_ID</span><span class="o">),</span>
                    <span class="n">someCommand</span><span class="o">,</span> <span class="n">answerCommand</span><span class="o">)</span>

<span class="n">tx</span><span class="o">.</span><span class="na">verify</span><span class="o">(</span><span class="n">serviceHub</span><span class="o">)</span>
</code></pre>
<p>Notice that:</p>

<ul>
<li><code>someNotary</code> is a notary node of your choice, for example <code>val someNotary = serviceHub.networkMapCache.notaryIdentities.first()</code></li>
<li><code>someState</code> is an output state that usually live along with the oracle answer</li>
<li><code>someContract</code> is a valid Corda contract listing all the assertion on the I/O states, by means of a <code>requireThat</code> closure (see below for more details about the contract)</li>
<li><code>someCommand</code> is a command which specify the operation being perfomed by the transaction including the issuer public key</li>
</ul>
<h3 id='sign-the-transaction'>Sign the transaction</h3><pre class="highlight java tab-java"><code><span class="c1">// Filter out non Oracles data</span>
<span class="n">fun</span> <span class="nf">filtering</span><span class="o">(</span><span class="nl">elem:</span> <span class="n">Any</span><span class="o">):</span> <span class="n">Boolean</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nf">when</span> <span class="o">(</span><span class="n">elem</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">is</span> <span class="n">Command</span><span class="o">&lt;*&gt;</span> <span class="o">-&gt;</span> <span class="n">oracle</span><span class="o">.</span><span class="na">owningKey</span> <span class="n">in</span> <span class="n">elem</span><span class="o">.</span><span class="na">signers</span> <span class="o">&amp;&amp;</span> <span class="n">elem</span><span class="o">.</span><span class="na">value</span> <span class="n">is</span> <span class="n">Answer</span>
        <span class="k">else</span> <span class="o">-&gt;</span> <span class="kc">false</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="n">val</span> <span class="n">ftx</span> <span class="o">=</span> <span class="n">txBuilder</span><span class="o">.</span><span class="na">toWireTransaction</span><span class="o">(</span><span class="n">serviceHub</span><span class="o">).</span><span class="na">buildFilteredTransaction</span><span class="o">(</span><span class="n">Predicate</span> <span class="o">{</span> <span class="n">filtering</span><span class="o">(</span><span class="n">it</span><span class="o">)</span> <span class="o">})</span>

</code></pre>
<p>Before sending the transaction to Provable for signing, it is customary to filter out all the non-Provable data as shown by the the function <code>filtering</code> on the right.</p>
<pre class="highlight java tab-java"><code><span class="n">val</span> <span class="n">signedTx</span> <span class="o">=</span> <span class="n">serviceHub</span><span class="o">.</span><span class="na">signInitialTransaction</span><span class="o">(</span><span class="n">tx</span><span class="o">)</span>
        <span class="o">.</span><span class="na">withAdditionalSignature</span><span class="o">(</span><span class="n">subFlow</span><span class="o">(</span><span class="n">OraclizeSignFlow</span><span class="o">(</span><span class="n">ftx</span><span class="o">)))</span>
</code></pre>
<p>Then the signature can be requested by using <code>OraclizeSignFlow</code> which accepts the <code>FilteredTransaction</code> defined before as argument. The flow will check that the query has actually been submitted in the past and then will return a <code>TransactionSignature</code> containing the one from <code>Provable</code>.</p>
<h2 id='details'>Details</h2><h3 id='the-provable-answer'>The Provable Answer</h3>
<p>The <code>Answer</code> model defined by Provable permits access to the following information:</p>

<ul>
<li><code>queryId</code>: the query ID of the current answer</li>
<li><code>rawValue</code>: the actual result (could be a ByteArray or a String)</li>
<li><code>value</code>: the string representation of the result (an hex string if it is a ByteArray)</li>
<li><code>proof</code>: the proof as a ByteArray</li>
<li><code>type</code>: a string specifying the type of the <code>rawValue</code> field

<ul>
<li><code>&quot;str&quot;</code> if it is a String</li>
<li><code>&quot;hex&quot;</code> if it is a ByteArray</li>
</ul></li>
</ul>
<h3 id='the-contract'>The contract</h3><pre class="highlight java tab-java"><code><span class="c1">// In the contract</span>
<span class="n">override</span> <span class="n">fun</span> <span class="nf">verify</span><span class="o">(</span><span class="nl">tx:</span> <span class="n">LedgerTransaction</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
    <span class="n">val</span> <span class="n">answerCommand</span> <span class="o">=</span> <span class="n">tx</span><span class="o">.</span><span class="na">commands</span><span class="o">.</span><span class="na">requireSingleCommand</span><span class="o">&lt;</span><span class="n">Answer</span><span class="o">&gt;()</span>

    <span class="n">requireThat</span> <span class="o">{</span>
        <span class="o">...</span>

        <span class="c1">// Check the Provable answer</span>
        <span class="n">val</span> <span class="n">rate</span> <span class="o">=</span> <span class="n">answerCommand</span><span class="o">.</span><span class="na">value</span><span class="o">.</span><span class="na">rawValue</span> <span class="n">as</span> <span class="n">String</span>
        <span class="s">"The rate USD/GBP must be over $USD_GBP_RATE_THRESH"</span> <span class="n">using</span> <span class="o">(</span><span class="n">rate</span><span class="o">.</span><span class="na">toDouble</span><span class="o">()</span> <span class="o">&gt;</span> <span class="n">USD_GBP_RATE_THRESH</span><span class="o">)</span>

        <span class="c1">// You can use the proof verification tool in the contract as well</span>
        <span class="n">val</span> <span class="n">proofVerificationTool</span> <span class="o">=</span> <span class="n">OraclizeUtils</span><span class="o">.</span><span class="na">ProofVerificationTool</span><span class="o">()</span>
        <span class="s">"Provable's proof verification failed"</span> <span class="n">using</span>  <span class="o">(</span>
                <span class="n">proofVerificationTool</span><span class="o">.</span><span class="na">verifyProof</span><span class="o">(</span><span class="n">answerCommand</span><span class="o">.</span><span class="na">value</span><span class="o">.</span><span class="na">proof</span> <span class="n">as</span> <span class="n">ByteArray</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
<p>As the answer is wrapped in a transaction by means of a command, you can easily access it inside a contract by using <code>tx.commands.requireSingleCommand&lt;Answer&gt;()</code> and check that the answer satisfies all the requirements.</p>

<p>On the right we verify that the value stored in the Answer is a constant above a certain threshold along with the verification of the proof requested.
If one of the above assertions fails the contract is rejected and the flow is stopped.</p>
<h3 id='rpc-calls'>RPC calls</h3><pre class="highlight plaintext"><code>&gt;&gt;&gt; start OraclizeQueryAwaitFlow  datasource: Wolfram, query: random number between 0 and 100, proofType: 0, delay: 0
</code></pre>
<p>It is also possible to call the <code>OraclizeQueryAwaitFlow</code> by RPC using the CRash shell (<code>&gt;&gt;&gt;</code>) as shown on the right.</p>
<h3 id='example'>Example</h3><pre class="highlight plaintext"><code>&gt;&gt;&gt; start Example amount: 10
&gt;&gt;&gt; run vaultQuery contractStateType: it.oraclize.cordapi.examples.states.CashOwningState
</code></pre>
<p>Inside the CorDapp you can find a ready-to-use example which self Issue the specified amount of cash if the rate of USD/GBP is above a certain threshold.
Check the <a href="https://github.com/oraclize/corda-api">corda-api</a> repository for the full details of how it works.</p>

<p>Then feel free to check the transaction by query the vault as shown on the right.</p>
<h3 id='adding-the-cordapp-to-your-project'>Adding the CorDapp to your project</h3><pre class="highlight gradle tab-gradle"><code><span class="k">repositories</span> <span class="o">{</span>
    <span class="n">maven</span> <span class="o">{</span> <span class="n">url</span> <span class="s1">'https://jitpack.io'</span> <span class="o">}</span>
<span class="o">}</span>
<span class="k">dependencies</span> <span class="o">{</span>
    <span class="n">compile</span> <span class="s2">"com.github.oraclize:corda-api:linux_x86_64-SNAPSHOT"</span>
<span class="o">}</span>
</code></pre>
<p>If you want to use Provable&#39;s CorDapp in your project just put one of the  dependencies in your <code>build.gradle</code> file:</p>

<ul>
<li><code>compile &quot;com.github.oraclize:corda-api:linux_x86_64-SNAPSHOT&quot;</code></li>
<li><code>compile &quot;com.github.oraclize:corda-api:win32_x86_64-SNAPSHOT&quot;</code></li>
<li><code>compile &quot;com.github.oraclize:corda-api:macosx_x86_64-SNAPSHOT&quot;</code></li>
</ul>

<p>&nbsp;<br></p>
<pre class="highlight plaintext"><code>Exception: J2V8 native library not loaded
</code></pre>
<aside class="notice">
To make the proof verification tool work correctly it is necessary that you put the right dependency corresponding to your node's architecture, otherwise the proof will fail raising an exception as the one displayed.
</aside>

          <h1 id='num-fabric'><a style="display:inline-block; min-width:20px">&num;</a> Fabric</h1>
<p>The following section is dedicated to the Provable integration with Hyperledger Fabric.</p>

<p>The Hyperledger Fabric platform supports Go, Node and Java as main programming languages for chaincodes; however, the current Provable integration (while it internally uses a Node chaincode) is provided in the form of an API which is made accessible via a Go package - this means that you will be able to use Provable from your <strong>Go</strong> chaincode with ease, but in the future Node/Java could be easily supported as well.</p>

<p>To better profit from this section of the documentation, previous knowledge of Go, Node, Docker and Hyperledger Fabric is required.</p>

<p>As said in previous sections, one of the fundamental characteristics of Provable is the capability of returning data to a contract, a chaincode in the Fabric space, together with one or more proofs of authenticity backing the data. The generation of an authenticity proof is optional and it must be configured by the chaincode developer when the request for data is initiated. Provable always recommends the use of authenticity proofs for production deployments.</p>
<h2 id='quick-start'>Quick Start</h2>
<p>The simplest way to introduce the Provable integration with Hyperledger Fabric, it is by showing a working example.</p>

<p>This example uses Provable to fetch the last EUR/USD exchange rate from cryptocompare.com APIs. The update process is initiated every time the query is sent. The example shows two important components needed when using Provable, both of which can be fetched from the <a href="https://github.com/oraclize/fabric-api">dedicated fabric-api Provable repository on Github</a>:</p>

<ul>
<li>The Provable connector chaincode <a href="https://github.com/oraclize/fabric-api/blob/master/connector/oraclize-connector.js">connector/oraclize-connector.js</a>, which should be installed on the network peer;</li>
<li>The Go package - <a href="https://github.com/oraclize/fabric-api/blob/master/oraclizeapi.go">oraclizeapi.go</a> - needed to use the Provable API from within a user-defined Go chaincode.</li>
</ul>

<aside class="notice">
Provable can currently be used free of charge in any Hyperledger Fabric networks. This will change in the near future and the standard pricing will apply: for more details please check out the pricing section of the documentation. The payment will be taken outside of the Fabric network with a dedicated user account holding some prepaid credit.
</aside>
<h3 id='prerequisites'>Prerequisites</h3>
<p>The Provable integration described in the document assumes the user to be familiar with at least one of the first tutorials provided by the Hyperledger Fabric documentation. The tutorial can be found at the following link: <a href="https://hyperledger-fabric.readthedocs.io/en/release-1.2/write_first_app.html">Writing Your First Application</a>.</p>
<h3 id='architecture-overview'>Architecture Overview</h3>
<p>In order to make the user approach the Hyperledger Fabric blockchain, several samples are provided through the official Hyperledger source. The folder containing these samples includes some basic network configurations really useful to have a clear and simple Provable integration. The folder <code>fabric-samples</code>, which includes the samples, can be downloaded executing the following command:</p>

<p><code>curl -sSL http://bit.ly/2ysbOFE | bash -s 1.2.0</code></p>

<p>That command downloads the <code>fabric-samples</code> folder; specifically the folder <code>fabric-samples/basic-network</code> is the <strong>network</strong> that we are going to use to showcase the Provable integration. The basic-network creates a network structure composed by the following entities:</p>

<ul>
<li>one application (cli);</li>
<li>one peer;</li>
<li>one orderer;</li>
<li>one CA</li>
</ul>

<p>On the peer two chaincodes will be installed:</p>

<ul>
<li>the <code>oraclize-connector</code>, the chaincode provided by Provable, that is used internally by Provable to execute any query;</li>
<li>the <code>user-chaincode</code>, the chaincode that the user wants to create in order to build a service in the Hyperledger Fabric blockchain.</li>
</ul>

<p>The <em>legend</em> concerning the living entities in this example of a Fabric network is shown in the following image:</p>

<p><img src="images/fabric-entities.png" width="65%" height="65%"></p>

<p>The <strong>network structure</strong> is displayed in architectural schema below:</p>

<p><img src="images/basic-network.png" width="52%" height="52%"></p>
<h3 id='transaction-flow'>Transaction Flow</h3>
<p>In this section we will analyze the transaction flow of a query performed in the <code>basic-network</code> example integrating Provable.
The 3 first steps of the transaction flow are displayed by the following figure:</p>

<p><img src="images/transaction-flow.png" width="55%" height="55%"></p>

<p>The flow can be divided in the process phases below:</p>

<ol>
<li>from the application A, the user starts a query directed to the peer P1, calling a function of the Go user chaincode S1, that calls an Provable query.</li>
<li>the user chaincode S1, executes the function invoked by the user, and send the data for the Provable query to the Provable connector, the chaincode S2;</li>
<li>the Provable chaincode S2, once the result is ready, sends it back to the user chaincode S1, along with the authenticity proof;</li>
<li>the user chaincode S1 does something with the result (and authenticity proof) received back from Provable and eventually sends back a response to the application A.</li>
</ol>
<h3 id='network-building'>Network Building</h3>
<p>This subsection goal is to build up the network described in the figure previously showed. First, access the <code>fabric-samples</code> folder and create a project folder for our Provable integration example. In this documentation, the name referring to it is <code>fabric-samples/oraclize-integration</code>.
This folder is the container for all the operations which happens from the application-cli side.
Inside the <code>oraclize-integration</code> folder, we will have the following files:</p>

<ul>
<li><code>enrollAdmin.js</code></li>
<li><code>registerUser.js</code></li>
<li><code>startFabric.sh</code></li>
<li><code>user-application-query.js</code></li>
</ul>

<p>Both files <code>enrollAdmin.js</code> and <code>registerUser.js</code> can be copied from the folder <code>fabric-samples/fabcar</code>.
The following commands can be launched from the folder <code>fabric-samples</code>:</p>

<ul>
<li><code>cp fabcar/enrollAdmin.js oraclize-integration</code></li>
<li><code>cp fabcar/registerUser.js oraclize-integration</code></li>
</ul>

<p>Then, in the <code>oraclize-integration</code> folder, install the packages below:</p>

<ul>
<li><code>npm install fabric-client</code></li>
<li><code>npm install fabric-ca-client</code></li>
</ul>
<pre class="highlight shell"><code><span class="c">#!/bin/bash</span>

<span class="c"># Do not rewrite paths for Windows Git Bash users</span>
<span class="nb">export </span><span class="nv">MSYS_NO_PATHCONV</span><span class="o">=</span>1
<span class="nv">starttime</span><span class="o">=</span><span class="k">$(</span>date +%s<span class="k">)</span>
<span class="nv">LANGUAGE</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">:-</span><span class="s2">"golang"</span><span class="k">}</span>
<span class="c"># CC_SRC_PATH refers to the docker cli container</span>
<span class="nv">CC_SRC_PATH</span><span class="o">=</span>github.com/user-chaincode/go
<span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$LANGUAGE</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"node"</span> -o <span class="s2">"</span><span class="nv">$LANGUAGE</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"NODE"</span> <span class="o">]</span>; <span class="k">then
    </span><span class="nv">CC_SRC_PATH</span><span class="o">=</span>/opt/gopath/src/github.com/oraclize-connector/node
<span class="k">fi</span>

<span class="c"># Clean the keystore</span>
rm -rf ./hfc-key-store
<span class="c"># Remove all the previously generated containers, representing entities and chaincodes</span>
docker stop <span class="k">$(</span>docker ps -aq<span class="k">)</span>
docker rm <span class="k">$(</span>docker ps -aq<span class="k">)</span>
docker rmi dev-peer0.org1.example.com-oraclize-connector-1.0-7765c3fb5c4224a4a2784d8a64a5488e570d39940695306f78f8e54009d89102
docker rmi dev-peer0.org1.example.com-user-chaincode-1.0-58b4cc4747da6f30d7cb2cea6511560c9fdad78c58ba6881b33801a2d69aebae

<span class="c"># Exit on first error</span>
<span class="nb">set</span> -e
<span class="c"># Go in the fabric-samples/basic-network folder to launch the network;</span>
<span class="nb">cd</span> ../basic-network
./start.sh

<span class="c"># Now launch the CLI container in order to install, instantiate chaincodes</span>
docker-compose -f ./docker-compose.yml up -d cli

<span class="c"># Instantiating the user chaincode (user-chaincode)</span>
docker <span class="nb">exec</span> -e <span class="s2">"CORE_PEER_LOCALMSPID=Org1MSP"</span> -e <span class="s2">"CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp"</span> cli peer chaincode install -n user-chaincode -v 1.0 -p <span class="s2">"</span><span class="nv">$CC_SRC_PATH</span><span class="s2">"</span> -l <span class="s2">"</span><span class="nv">$LANGUAGE</span><span class="s2">"</span>
<span class="c"># Installing the user chaincode (user-chaincode)</span>
docker <span class="nb">exec</span> -e <span class="s2">"CORE_PEER_LOCALMSPID=Org1MSP"</span> -e <span class="s2">"CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp"</span> cli peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n user-chaincode -l <span class="s2">"golang"</span> -v 1.0 -c <span class="s1">'{"Args":[""]}'</span> -P <span class="s2">"OR ('Org1MSP.member','Org2MSP.member')"</span>

<span class="c"># Instantiating the Provable chaincode (oraclize-connector)</span>
docker <span class="nb">exec</span> -e <span class="s2">"CORE_PEER_LOCALMSPID=Org1MSP"</span> -e <span class="s2">"CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp"</span> cli peer chaincode install -n oraclize-connector -v 1.0 -p <span class="s2">"/opt/gopath/src/github.com/oraclize-connector/node"</span> -l <span class="s2">"node"</span>
<span class="c"># Installing the Provable chaincode (oraclize-connector)</span>
docker <span class="nb">exec</span> -e <span class="s2">"CORE_PEER_LOCALMSPID=Org1MSP"</span> -e <span class="s2">"CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp"</span> cli peer chaincode instantiate -o orderer.example.com:7050 -C mychannel -n oraclize-connector -l <span class="s2">"node"</span> -v 1.0 -c <span class="s1">'{"Args":[""]}'</span> -P <span class="s2">"OR ('Org1MSP.member','Org2MSP.member')"</span>

<span class="c"># Go back to the user application folder and install all the node_modules</span>
<span class="nb">cd</span> ../oraclize-integration
npm install

<span class="c"># Enroll the admin</span>
node enrollAdmin.js
<span class="c"># Register the user</span>
node registerUser.js
</code></pre>
<p>Download the file called <code>fabric-examples/eurusd-example/testing-utils/startFabric.sh</code> from the <a href="https://github.com/oraclize/fabric-examples">fabric-examples Provable repository on Github</a>. This script is shown in full in the code section on the right and it is the script used to execute the following operations in order:</p>

<ol>
<li>set the environment variables;</li>
<li>clean the certificates and the keystore, deleting the <code>hfc-key-store</code> folder;</li>
<li>stop and remove all the previous docker containers which represent the network entities;</li>
<li>remove the chaincode containers;</li>
<li>launch the network <code>fabric-samples/basic-network</code>, creating a docker container for:

<ul>
<li>the orderer;</li>
<li>the CA;</li>
<li>the peer;</li>
<li>the cli;</li>
<li>the couchdb;</li>
</ul></li>
<li>launch the <em>cli</em> to install and instantiate the <code>oraclize-connector</code> and the <code>user-chaincode</code> chaincodes, launching them as containers;</li>
<li>install the node modules;</li>
<li>enroll the admin calling <code>enrollAdmin.js</code>;</li>
<li>register the user, calling <code>registerUser.js</code>.</li>
</ol>

<aside class="notice">
Please note that Go must be installed, and that the Go environment variables must be correctly set.
</aside>
<h3 id='adding-the-provable-chaincode'>Adding the Provable Chaincode</h3><pre class="highlight json tab-json"><code><span class="p">{</span><span class="w">
    </span><span class="s2">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"oraclize-connector"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"version"</span><span class="p">:</span><span class="w"> </span><span class="s2">"1.0.0"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"oraclize-connector chaincode implemented in node.js"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"engines"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"node"</span><span class="p">:</span><span class="w"> </span><span class="s2">"&gt;=8.4.0"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"npm"</span><span class="p">:</span><span class="w"> </span><span class="s2">"&gt;=5.3.0"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="s2">"scripts"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"start"</span><span class="p">:</span><span class="w"> </span><span class="s2">"node oraclize-connector.js"</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="s2">"engine-strict"</span><span class="p">:</span><span class="w"> </span><span class="kc">true</span><span class="p">,</span><span class="w">
    </span><span class="s2">"license"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Apache-2.0"</span><span class="p">,</span><span class="w">
    </span><span class="s2">"dependencies"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="s2">"cbor-sync"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^1.0.2"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"fabric-shim"</span><span class="p">:</span><span class="w"> </span><span class="s2">"unstable"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"node-pre-gyp"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^0.10.3"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"request"</span><span class="p">:</span><span class="w"> </span><span class="s2">"^2.87.0"</span><span class="w">
    </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre>
<p>In the <code>startFabric.sh</code> script, the last two docker commands refer to the instance and install the Provable connector chaincode. This chaincode, referred in the documentation with the name of <code>oraclize-connector</code>, is instantiated on the network peer from the cli docker container.</p>

<p>The cli container instantiate and install the oraclize chaincode from its local chaincodes set. However, the cli takes this chaincode set from the folder <code>fabric-samples/chaincode</code>; as a result, the <em>node.js</em> <code>oraclize-connector</code> and the <em>Go</em> <code>user-chaincode</code> have to be in the mentioned path.</p>

<p>The <code>oraclize-connector.js</code> chaincode is provided by Provable at <a href="https://github.com/oraclize/fabric-api/">fabric-api/connector Provable repository on Github</a> and has to be put in the following path <code>fabric-samples/chaincode/oraclize-connector/node</code>, so that the final result will be: <code>fabric-samples/chaincode/oraclize-connector/node/oraclize-connector.js</code>.</p>

<p>For correctly set the <code>oraclize-connector</code> chaincode, the files <code>oraclize-connector.js</code> and the <code>package.json</code> are needed. The <code>package.json</code> is required to install the specified dependencies, while the <code>oraclize-connector.js</code> is the node Provable chaincode itself.</p>

<aside class="notice">
Please, note that the paths and names mentioned have not be changed for a correct integration.
</aside>
<h3 id='adding-the-user-chaincode'>Adding the User Chaincode</h3><pre class="highlight javascript tab-javascript"><code><span class="nx">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">SmartContract</span><span class="p">)</span> <span class="nx">fetchEURUSDviaOraclize</span><span class="p">(</span><span class="nx">APIstub</span> <span class="nx">shim</span><span class="p">.</span><span class="nx">ChaincodeStubInterface</span><span class="p">)</span> <span class="nx">sc</span><span class="p">.</span><span class="nx">Response</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">datasource</span> <span class="o">=</span> <span class="s2">"URL"</span>
    <span class="kd">var</span> <span class="nx">query</span> <span class="o">=</span> <span class="s2">"json(https://min-api.cryptocompare.com/data/price?fsym=EUR&amp;tsyms=USD).USD"</span>
    <span class="nx">result</span><span class="p">,</span> <span class="nx">proof</span> <span class="p">:</span><span class="o">=</span> <span class="nx">oraclizeapi</span><span class="p">.</span><span class="nx">ProvableQuery_sync</span><span class="p">(</span><span class="nx">APIstub</span><span class="p">,</span> <span class="nx">datasource</span><span class="p">,</span> <span class="nx">query</span><span class="p">,</span> <span class="nx">oraclizeapi</span><span class="p">.</span><span class="nx">TLSNOTARY</span><span class="p">)</span>
    <span class="k">return</span> <span class="nx">shim</span><span class="p">.</span><span class="nx">Success</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre>
<p>Create a folder that will contain your chaincode in<code>fabric-samples/chaincode</code>, in this example <code>fabric-samples/chaincode/user-chaincode/go</code>. Create the Go chaincode, in this example the referred name is <code>user-chaincode.go</code>. Now, the Provable Go package has to be included, in order to perform an Provable query.
On the <a href="https://github.com/oraclize/fabric-examples">fabric-examples/eurusd-example/chaincode/go/ Provable repository on Github</a> we provide a ready-to-use user chaincode. Inside the chaincode, all the dependencies needed are included, including the <code>oraclizeapi.go</code>.
However, you need to install the dependencies locally, using the command:</p>

<p><code>go get &quot;github.com/oraclize/fabric-api&quot;</code></p>

<p>Please note that all the go packages, including the <code>oraclizeapi.go</code>, must be vendored in your chaincode folder <code>fabric-samples/chaincode/user-chaincode/go</code>. In general, vendoring the package with <a href="https://github.com/kardianos/govendor">govendor</a> can be a good solution to include a package in the user chaincode. The package must appear in the <code>vendor</code> folder at the following path: <code>fabric-samples/chaincode/user-chaincode/go/vendor</code>.</p>

<p>The package allows to perform a request for data using an Provable query function, with the following code:
<code>oraclizeapi.OraclizeQuery_sync(APIstub, dataset, url, proofType)</code></p>

<p>The code of a function performing a call for the EUR/USD exchange rate data using an Provable query in the user chaincode is shown on the right. The proof required by the chaincode in the example is the TLSNOTARY proof.</p>
<h3 id='provable-simple-query'>Provable Simple Query</h3>
<p>A request for data is called <strong>query</strong>. The <code>OraclizeQuery_sync</code> is a function, implemented in the <code>oraclizeapi.go</code> Go package, which expects three arguments:</p>

<ul>
<li>A data-source such as <code>URL</code>, <code>WolframAlpha</code>, <code>IPFS</code>, <code>Swarm</code> and others listed here</li>
<li><p>The argument for the given data-source; for examples:</p>

<ul>
<li>the full <code>URL</code>, which may include the use of JSON or XML parsing helpers as it can be seen in the previous example</li>
<li>or a <code>WolframAlpha</code> formula</li>
<li>or an <code>IPFS</code> multihash</li>
</ul></li>
<li><p>The proof type, that can be specified using the following values, imported from <code>oraclizeapi.go</code>:</p>

<ul>
<li>NONE</li>
<li>TLSNOTARY</li>
<li>ANDROID</li>
<li>LEDGER</li>
<li>NATIVE</li>
</ul></li>
</ul>

<p>The number and type of supported arguments depends on the data-source in use.</p>
<h3 id='sending-cli-queries'>Sending CLI Queries</h3><pre class="highlight javascript tab-javascript"><code><span class="kr">const</span> <span class="nx">request</span> <span class="o">=</span> <span class="p">{</span> <span class="na">chaincodeId</span><span class="p">:</span> <span class="s2">"user-chaincode"</span><span class="p">,</span> <span class="na">fcn</span><span class="p">:</span> <span class="s2">"fetchEURUSDviaOraclize"</span><span class="p">,</span> <span class="na">args</span><span class="p">:</span> <span class="p">[]</span> <span class="p">}</span>
</code></pre>
<p>In order to test the example function <code>fetchEURUSDviaOraclize</code> which calls the Provable query from the <code>user-chaincode</code>, you need to start the network first.
After launching the Docker daemon, you proceed by running the following command from the folder <code>fabric-samples/oraclize-integration</code>:</p>

<p><code>./startFabric.sh</code></p>

<p>Then, when the network is fully up, with all its 7 containers (4 entities, 2 chaincodes, 1 couchdb),
run the application query file <code>user-application-query.js</code>, with the command:</p>

<p><code>node user-application-query.js</code></p>

<p>The EUR/USD exchange rate result is returned with the authenticity proof specified chaincode side.</p>

<aside class="notice">
For the full code the example file above please refer to the
    <a href="https://github.com/oraclize/fabric-examples">fabric-examples Provable repository on Github</a>
.
</aside>

          <h1 id='development-tools'>Development Tools</h1>
<p>In this section, developers will find some of tools which can assist them into integrating Provable in their product.</p>
<h2 id='test-query'>Test Query</h2>
<p>The <a href="https://app.oraclize.it/home/test_query" target="_blank">TestQuery</a> page can be used to test any Provable query. This does not require any code to be written and can be useful to verify the correctness of a given query during the early development stage.</p>
<h2 id='network-monitor'>Network Monitor</h2>
<p>The <a href="https://app.oraclize.it/service/monitor" target="_blank">Network Monitor</a>, along with the <a href="https://github.com/oraclize/proof-verification-tool" target="_blank">Proof Verification Tool</a>, can be used to verify the integrity and correctness of the authenticity proofs Provable has provided.</p>

<p>It is very important to independently verify that those proofs are valid, as this is the only way it can verified if Provable has ever provided a wrong answer.</p>
<h2 id='encryption'>Encryption</h2>
<p>In order to use the encryption-enabling features of Provable, developers can use the <a href="https://app.oraclize.it/home/test_query" target="_blank">TestQuery</a> page or the <a href="https://github.com/oraclize/encrypted-queries" target="_blank">Python Encryption Tool</a>. To avoid replay attacks, the encrypted query is linked to the first smart contract which uses it to perform a request to Provable. New deployment of the same smart contract code will required to newly encrypt the query.</p>
<h2 id='remix-ide-provable-plugin'>Remix IDE Provable Plugin</h2>
<p>The Remix IDE is bundled with a variety of plugins, including one for using Provable as an oracle service. This plugin is intended for use with the JavaScript VM, which upon loading deploys all the needed infrastructure and listeners for your session. Thereafter you may deploy any contracts utilizing Provable via inheritance of the usingOraclize contract and track any query requests done through the plugin icon on the side panel of the IDE.</p>

<p>For some example contracts, please refer to the <a href="https://github.com/oraclize/ethereum-examples/tree/master/solidity" target="_blank">ethereum-examples</a> github repository. Contracts in the root directory like DieselPrice.sol and KrakenPriceTicker.sol are plug and play, in that you can simply run them in Remix with the plugin, and they will work.</p>

<aside class="notice">
The plugin only works with the JavaScript VM environment on Remix, in the case of using a web3 provider or injected environment, the network in question will either need to be supported by Provable directly, which is true for for the public testnets or mainnet, or in the case of a private network, will require manual setup via the `ethereum-bridge`.
</aside>
<h2 id='unit-testing'>Unit Testing</h2>
<p>An important step in smart contract development, before moving to an official testnet or production use, is unit testing. The Ethereum community has developed multiple frameworks for unit testing, such as Truffle and Embark, which can test contracts on a private instance of Ethereum. A common combination is to run Truffle tests in an ethereumjs-testrpc environments, which is a simulated Ethereum blockchain instance running in memory.
In order for Provable to interact with the smart contract deployed by Truffle or Embark in the test-rpc blockchain instance, a tool called Ethereum-Bridge need to be installed. This is a nodejs module which deploys in the instance the Provable smart contracts infrastructure which it is then monitored to see the requests. The tool translates the requests to HTTP API calls to the Provable Engine and then return the result by broadcasting the callback transaction. The Ethereum-Bridge and instructions on its deployment can be found <a href="https://github.com/oraclize/ethereum-bridge">here</a>.</p>
<h2 id='ethpm'>EthPM</h2>
<p>The <a href="https://www.ethpm.com/">Ethereum Package Management</a> is a project which aims to standardize, build and maintain a common registry of smart contracts-based packages, to help smart contract developers.
Provable has published and maintains the Ethereum oraclizeAPI under the &#39;oraclize-api&#39; package. To install it: `truffle install oraclize-api&#39;.</p>

<aside class="notice">
Please note that the correct package name is named `oraclize-api` and not `oraclize`.
</aside>
<h3 id='oraclize-lib'>Oraclize-lib</h3>
<p><a href="https://github.com/oraclize/oraclize-lib" target="_blank">Oraclize-lib</a> is an experimental nodejs library that be used to build non-blockchain applications leveraging Provable. It can be considered a simple abstraction layer to the Provable HTTP API.</p>
<h2 id='future'>Future</h2><h3 id='stargate'>Stargate</h3>
<p>The Provable team is working on a tool which will enable direct integration with any private deployment of Ethereum-based chain, including private testnet, without installing additional software. This tool has been named Stargate and it is under active development. The tool will consist of an ssh-bridge between the developer blockchain instance and Provable.
Additional information will be available later this year. Parties interested in trying this experimental feature, can get <a href="mailto:info@oraclize.it">in touch with us</a>.</p>

          <h1 id='security-deep-dive'>Security Deep Dive</h1>
<p>As digital technologies have reduced the barrier to entries for information creation and distribution, it has become extremely important to be able to authenticate a piece of information as originating from a known, trusted source.</p>

<p>In the context of web technologies, <em>authentication</em> is provided by the HTTPS protocol, an extension of the HTTP protocol which create an encrypted and authenticated channel between the client and the web-server containing the data.</p>

<p>When dealing with data which could be used to determine different financial transactions, authentication becomes of fundamental importance. Unfortunately, the most used and available blockchain protocols have no direct way of interacting with HTTPS and therefore digesting authenticated data. It would seem then that there is a need for a trusted service which can provide this data or complete actions based on it; but that would in part defeat the point of having a decentralized protocol for exchanging value <em>without</em> trusted parties.</p>

<p>This is the reason why Provable has been designing systems for authenticating data and made it part of its core business. These systems are called <em>authenticity proofs</em>, which enable auditability of the oracle&#39;s service record in delivering untampered data.
The authenticity proofs leverage different attestation technologies: some are software-based and some rely on trusted hardware technologies.</p>
<h2 id='authenticity-proofs-types'>Authenticity Proofs Types</h2><h3 id='tlsnotary-proof'>TLSNotary Proof</h3>
<p>The TLSNotary Proof leverages a feature of the TLS 1.0 and 1.1 protocols which enables the splitting of the TLS master key between three parties: the server, an auditee and an auditor. In this scheme, Provable is the auditee while a locked-down AWS instance of a specially-designed, open-source Amazon Machine Image acts as the auditor. The TLSNotary protocol is an open-source technology, developed and used by the PageSigner project.</p>
<h3 id='android-proof'>Android Proof</h3>
<p>The Android Proof is a result of some of Provable&#39;s internal R&amp;D work. It leverages software remote attestation technology developed by Google, called SafetyNet, to validate that a given Android application is running on a safe, non-rooted physical device, connected to Provable&#39;s infrastructure. It also remotely validates the application code hash, enabling authentication of the application running on the device. The application code is open-source, thereby enabling auditability and verification of the code hash. The Android Proof goes further, by using the newly introduced Android Hardware Attestation to prove that the physical device is updated to the latest available Android version, further ensuring integrity by having any potential exploits within the system patched. Furthermore, it verifies that the device&#39;s Root-of-Binding-Trust is valid. Both these technologies together effectively turn the physical Android device into a provably-secure environment in which an untampered HTTPS connection to a remote datasource can be initiated. For Provable or an external attacker with unauthorized gained access to the infrastructure to compromise the device and generate a false but valid proof, a zero-day exploit unbeknownst to Google must be discovered by said party, which either breaks the Android sandboxing model or is a kernel-level exploit, of the latest version of Android OS and its available security patches.
You can access more information about the Android Proof by reading the white paper on it and experiment with it on the Ethereum and Bitcoin testnets. The enabling of the Android Proof on mainnet is pending based on an update by Google, effectively enabling Android Nougat Hardware Attestation.</p>
<h3 id='ledger-proof'>Ledger Proof</h3>
<p><a href="https://www.ledger.co">Ledger</a> is a French company, leader in the production of hardware-enforced cryptocurrency wallets. Their main products are the Ledger Nano S and the Ledger Blue. Both devices implement a common platform comprising a STMicroelectronics secure element, a controller and an operating system called BOLOS.
The BOLOS SDK enables developer to build applications which can be installed on the secure hardware along with the cryptocurrency wallet, which are BOLOS application themselves.
BOLOS exposes a set of kernel-level API which can complete useful operations such as cryptographic ones or attestation. Attestation is in fact one of the most interesting aspect of the platform: any application can, by calling the appropriate API, ask the kernel to measure its binary and produce a signed hash. The signing is performed by a special attesting key, which is controlled by the kernel and it is out of reach of the application developers. The attesting key has full chain of trust which has the root in a Ledger-controlled master key, residing on an HSM controlled by Ledger.</p>

<p>The Ledger Proof leverages both the code attesting and the device attesting features to attest to any third-party that the applications developed by Provable are running in a TEE of a true Ledger device. The Ledger Proof has the following format:</p>

<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody>
<tr>
<td>3 bytes</td>
<td>65 bytes</td>
<td>var length</td>
<td>...</td>
</tr>
<tr>
<td>'LP\x01' (prefix)</td>
<td>APPKEY1 PubKey</td>
<td>APPKEY1 cert (CA:Ledger)</td>
</tr></tbody></table>

<ol>
<li>A prefix to indicate proof type and versioning</li>
<li>The attesting key <code>app_key_1</code> of the device.</li>
<li>Signature by the Ledger Root Key over the <code>app_key_1</code></li>
<li>The data and signatures of the application</li>
</ol>

<p>The Ledger Proof is currently used by the Provable Random Data Source to provide untampered entropy to smart-contracts, blockchain and non-blockchain applications.</p>
<h3 id='storage-and-delivery'>Storage and Delivery</h3>
<p>The authenticity proofs may be relatively large files, of up to a few kilobytes. Delivering such proofs directly within the result of the data payload in an Ethereum transaction can get quite expensive, in terms of EVM execution costs, and may even be impossible for larger data.</p>

<p>Moreover, Provable strives to be blockchain agnostic, enabling the proof to be used even on Bitcoin and other blockchains. Therefore the proof is uploaded and saved to IPFS, a decentralized and distributed storage system. In providing a pointer to the content, IPFS uses a custom hashing algorithm called multihash. The resulting address is Base64 encoded and it&#39;s a unique ID specific to the file which can be used to access it globally, and changes along with any edits to the file contained.</p>

<p>IPFS, by itself, doesn&#39;t provide any long-term guarantees of persistency, however as part of Provable&#39;s infrastructures it runs the <a href="https://github.com/oraclize/ipfs-persistence-consortium" target="_blank">IPFS persistence consortium</a>. Anyone can join Provable&#39;s consortium and help in keeping an independent copy of all the proofs by pointing a <a href="https://github.com/oraclize/ipfs-persistence-consortium" target="_blank">IPFS persistence consortium</a> node to the following aggregation peer: <code>QmSsSSfJAJwj3jsNfzbSrxtLAjhpYPjbUEsCQT8mWVgBiL</code></p>
<h2 id='advanced-data-sources'>Advanced Data Sources</h2><h3 id='random-data-source'>Random Data Source</h3>
<p>The Provable Random Data Source leverages the Ledger Proof and a custom application to generate unbiased random numbers and provide them on demand to blockchain and non-blockchain based applications. The end applications can perform verification step to unsure that the randomness provided was truly generated in an secure hardware environment provided by a Ledger Nano S.</p>

<p>This section will shortly explain the rationale and the inner workings of the custom application.</p>

<p>The main goals of the design were:</p>

<ol>
<li>Provable can only ask once, for a specific request, a random number to the device. Subsequent requests should be denied or return the previously extracted number.</li>
<li>The random number must be signed, to authenticate that has been generated by the device.</li>
<li>In blockchain applications, miners shouldn&#39;t be able to tamper with orders, validity and results of the bets</li>
<li>The design should minimize use of state both on the device and on-chain.</li>
</ol>

<p>The architecture achieves these goals by:</p>

<ol>
<li>Enforcing the uniqueness of each request id. The device keeps a merkelized, append-only state where each request seen is appended.</li>
<li>All data coming from the device is signed by an application session key, whose public key is present in the Provable connector. Requests can commit to receive the result by a precise session key.</li>
<li>Commitment data is send along with the request, to anchor it to a specific blockchain history. Commitment data can be derived by the current block information such as timestamp, coinbase and previous block hash, and additionally information related to the request (msg.sender, msg.value etc).</li>
<li>The kernel has an event feature which it is used to increment an application internal timer. A request can and should specify a time, in seconds, which has to elapse before the request can be served by the device and the random number returned. The higher the specifier time, the stronger the security against miners, with or without Provable collaboration, tampering with the result.</li>
<li>The random bytes are generated from the commitment data and the session private key using the ECDSA deterministic signing; this avoids costly recomputation of the tree to mark served query.</li>
</ol>

<p>The validity of these operations is enforced by the Ledger Proof. Signatures and data related to the Random Data Source are in fact append to the Ledger Proof and returned with the result. The format of the appended data is the following one:
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
</tr>
</thead>
<tbody>
<tr>
<td>32 bytes</td>
<td>32 bytes</td>
<td>8 bytes</td>
<td>1 byte</td>
<td>32 bytes</td>
<td>var length</td>
<td>65 bytes</td>
<td>var length</td>
</tr>
<tr>
<td>CODEHASH</td>
<td>keyhash</td>
<td>timelock</td>
<td>Nbytes</td>
<td>user nonce</td>
<td>SessionKey sig</td>
<td>SessionPubKey</td>
<td>attestation sig</td>
</tr></tbody></table></p>

<ol>
<li>The SHA-256 of the application binary, measured by the BOLOS kernel</li>
<li>The uniqueId hash</li>
<li>The time which has to elapse before the request can be answered</li>
<li>The number of random bytes which have to be returned</li>
<li>The commitment data, chosen by the developer</li>
<li>The signature of the application session key over the request data</li>
<li>The application session public key</li>
<li>The signature of <code>app_key_1</code>, the attesting key, over the codehash and the session public key</li>
</ol>

<p>An in-depth explanation of the Random Data Source and an analysis of the attack scenarios can be consulted in the released paper.</p>

          <h1 id='pricing'>Pricing</h1>
<p>The use of Provable requires the payment of a small fee, which depends from the data source type used and by the authenticity proof requested. The pricing listed below is valid for both Ethereum and Rootstock. There is a baseprice for the query itself. When the <code>oraclize_query</code> gets called the needed ETH has to be transfered to Provable to pay for sending the callback transaction back to the contract.</p>

<p>Since this cost depends on the code and preferences (gasprice), it can vary a lot depending on the two of them. To prevent unneccessary costs you should estimate and set the gasprice and the gas as precise as possible, so that you get reasonable confirmation times and so that your callback transaction works as expected (without running out of gas).</p>
<h3 id='first-free-request'>First Free Request</h3>
<p>To facilitate testing, the first call to Provable from any smart contract address, if used with standard setting, is free of charge. This includes the gas costs of the callback transaction.</p>
<h3 id='testnets-policy'>Testnets Policy</h3>
<p>To keep compatibility with the main-net deployed, smart contracts testing Provable on any of the testnets are expected to pay the same fee they would on the main-net. Since the payment expected is in testnet Ether, which holds no value, the calls to Provable are de facto free.
Provable reserve the rights to discontinue the service for abuse or excessive use.</p>
<h3 id='call-fee'>Call Fee</h3>
<p>The <code>oraclize_query</code> automatically recovers the fee at execution time. The fee consist of two parts:</p>

<ul>
<li>The amount of Wei which corresponds, using a recent exchange rate, to the USD price for the data source and the authenticity proof requested</li>
<li>The amount of Wei which Provable will spend in gas for sending the callback transaction</li>
</ul>

<style type="text/css">
    tr, td, th {
        text-align: center !important;
        vertical-align: middle !important;
    }
</style>

<table>
  <tr>
    <th rowspan="2" style="vertical-align: bottom !important;">Datasource</th>
    <th rowspan="2" style="vertical-align: bottom !important;">Base price</th>
    <th colspan="4">Proof type</th>
  </tr>
  <tr>
    <td>None</td>
    <td>TLSNotary</td>
    <td>Android</td>
    <td>Ledger</td>
  </tr>
  <tr>
    <td>URL</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.01$</td>
    <td>+0.0$</td>
    <td>+0.04$</td>
    <td>+0.04$</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>WolframAlpha</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.03$</td>
    <td>+0.0$</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>IPFS</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.01$</td>
    <td>+0.0$</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>random</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.05$</td>
    <td>+0.0$</td>
    <td>N/A</td>
    <td>N/A</td>
    <td>+0.0$</td>
  </tr>
  <tr>
    <td>computation</td>
    <td style="background-color:#FFEFD0;font-weight: 700;">0.50$</td>
    <td>+0.0$</td>
    <td>+0.04$</td>
    <td>+0.04$</td>
    <td>N/A</td>
  </tr>
</table>
<h3 id='onchain-vs-offchain-payments'>Onchain vs. Offchain Payments</h3>
<p>When paying onchain there is no reliable backward-compatible way for Provable to give back the gas &quot;change&quot;. This is due to how Ethereum works: it is not possible to determine the exact amount of gas that will be used before the transaction gets confirmed, because it depends on the current state. Sending back the unspent gas afterwards would potentially create side effects.</p>

<p>Provable is now supporting offchain payments too. When using that option you will get back the unused gas as the charge happens on a prepaid account outside of the blockchain. Interested parties should get in touch at info@oraclize.it</p>
<h3 id='nested-queries'>Nested Queries</h3>
<p>Currently nested queries are being priced as a single query. In the near future the pricing for the nested queries will be a sum of the datasources you decide to use. At the moment the pricing is reduced to one single datasource, however your smart contract should take into account that the full pricing will apply at some point.</p>

          <h1 id='tutorials'>Tutorials</h1>
<p>On the Provable <a href="https://www.youtube.com/channel/UCjVjCheDbMel-x-JYeGazcQ/featured">Youtube channel</a> you can find some useful video to start using the Provable integration.</p>
<h2 id='ethereum'>Ethereum</h2>
<ul>
<li><p><a href="https://www.youtube.com/watch?v=v2Skr_m0J2E&amp;t=31s">Getting Started on Ethereum</a></p></li>
<li><p><a href="https://www.youtube.com/watch?v=GkkDXpOXn5c">Best Practices for using Provable on Ethereum</a></p></li>
<li><p><a href="https://www.youtube.com/watch?v=J05DBPdkeAo&amp;t=167s">Retrieve a Random Number via Provable</a></p></li>
</ul>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="javascript"></a>
          </div>
      </div>
    </div>
    <span id='chat'><a href='https://gitter.im/provable/home' target='_blank'><img src='images/gitter.png' width=120></a></span>
    <script>
    var isMobile = false; //initiate as false
    // device detection
    if(/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(navigator.userAgent.substr(0,4))) isMobile = true;
    
    if (!isMobile){
      $(document).ready(function(){
        setTimeout(function(){
          $("#chat").slideDown();
        }, 1500);
      });
      $("#chat img").mouseover(function(){ $(this).animate({width: "140px"}, "fast"); });
      $("#chat img").mouseout(function(){ $(this).animate({width: "120px"}, "fast"); });
    }
    
    $.get('lastupdate.txt', function(date){
	$('#lastupdate').html('Last update: '+date.trim());
    }, 'text');

    $('a[href^="#"]').on('click',function(e){
      e.preventDefault();
      var href = $(this).attr('href');
      if(typeof(href)=='undefined') return;
      if(href.indexOf('-')!==-1) scrollToSection(href);
      else location.hash = href;
    });

    function scrollToSection(href){
      $('html,body').animate({
        scrollTop: $('div[data-unique='+href.substr(1)+']').offset().top+60,
      },0);
    }
    </script>
  </body>
</html>
